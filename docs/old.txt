;;----------------------------------------------;;

data XdgDirectory

  = XdgData
    -- ^ For data files (e.g. images).
    --   Defaults to @~\/.local\/share@ and can be
    --   overridden by the @XDG_DATA_HOME@ environment variable.
    --   On Windows, it is @%APPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Roaming@).
    --   Can be considered as the user-specific equivalent of @\/usr\/share@.

  | XdgConfig
    -- ^ For configuration files.
    --   Defaults to @~\/.config@ and can be
    --   overridden by the @XDG_CONFIG_HOME@ environment variable.
    --   On Windows, it is @%APPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Roaming@).
    --   Can be considered as the user-specific equivalent of @\/etc@.

  | XdgCache
    -- ^ For non-essential files (e.g. cache).
    --   Defaults to @~\/.cache@ and can be
    --   overridden by the @XDG_CACHE_HOME@ environment variable.
    --   On Windows, it is @%LOCALAPPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Local@).
    --   Can be considered as the user-specific equivalent of @\/var\/cache@.

;;----------------------------------------------;;

(pcase sboo-xdg-platform

  ('posix ())

  ('windows ())
  
  (_ ()))

;;----------------------------------------------;;


(cl-defun sboo-xdg-xyz (path &key subdir)

  "Make an xdg path for xyz files, from PATH.

Inputs:

• PATH   — a string. the suffix of the filepath to output.
• SUBDIR — a string. if non-nil (or absent), prefix PATH with SUBDIR.

Output: a string. \"$XDG_XYZ_HOME/SUBDIR/PATH\".

Example:

• M-: (sboo-xdg-xyz \"directory/basename.txt\")
      \"~/.directory/basename.txt\"

• M-: (sboo-xdg-xyz \"basename.txt\" :subdir \"directory\")
      \"~/.directory/basename.txt\"

« $XDG_XYZ_HOME » defaults to:

• « ~/.xyz » — on POSIX.
• «  » — on Windows.'

Use for (e.g. ).

See URL `https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html'.

Related:

• `sboo-xdg-xyz-default'
• `sboo-xdg-xyz-environment'"

  (let ((XdgPathEnvironment (getenv "XDG_XYZ_HOME"))
        (XdgPathDefault     "~/.xyz")
        (XdgPath            (if XdgPathEnvironment
                                XdgPathEnvironment
                              (file-name-as-directory XdgPathDefault)))
        (SubDirectory       (if subdir
                                (file-name-as-directory subdir)
                              ""))
        )

    (file-truename (cocnat XdgPath Subdir Path))))

;;----------------------------------------------;;


(defun sboo-next-buffer (count)
 
  "Move COUNT buffers 'forwards'.
"

  (interactive )

  (progn
  
    ()))

(defun sboo-prior-buffer (count)
 
  "Move COUNT buffers 'backwards'.
"

  (interactive )

  (progn
  
    ()))

;;----------------------------------------------;;

(defconst platform

  (cond                                 ;TODO pcase `(,system-type ,window-system)

   ((or (memq system-type   '(gnu/linux)))

    'platform-linux)

   ((or (memq system-type   '(cygwin windows-nt ms-dos))
        (memq window-system '(w32 pc)))

    'platform-windnows)

   ((or (memq system-type   '(darwin))
        (memq window-system '(mac ns)))

    'platform-apple)

   ((or (eq window-system 'x))  ;; TODO and Wayland?
    ;; ^ X11 runs on non-Linux operating-systems too (like Apple).

    'platform-linux)

   (t
    'platform-unknown))

  "The current platform, a symbol (prefixed with `platform-').

One of: 

* 'platform-linux
* 'platform-windows
* 'platform-apple
* 'platform-unknown

Depends on the variables `system-type' and `window-system'.")

;;----------------------------------------------;;

  (pcase `(,system-type . ,window-system)

    ( `( ,(or 'gnu/linux) . ,_ )

      'platform-linux)

    ( `( ,_ . ,_ )

      'platform-unknown))

;;----------------------------------------------;;

  (pcase (list system-type window-system)

    ( `(,(or 'gnu/linux) ,_)

      'platform-linux)

    ( ,_

      'platform-unknown))

  
;;----------------------------------------------;;
  (use-package dante
    :after    haskell

    :commands (dante-mode dante-restart)

    :bind (:map haskell-mode-map
                (("C-c d" . sboo-dante-mode)))

;;;  :hook ((haskell-mode . flycheck-mode)
;;;         (haskell-mode . dante-mode))

    :init
    (add-hook 'haskell-mode-hook #'flycheck-mode)
    (add-hook 'haskell-mode-hook #'dante-mode)

    :config
    (setq dante-repl-command-line-methods-alist
          sboo-dante-repl-command-line-methods-alist)

    (setq sboo-haskell-eldoc 'dante)

    (setq dante-tap-type-time 2)

    ())

;;----------------------------------------------;;

(defun sboo--ghc-pragma-read (prompt candidates)

  "Read a candidate from CANDIDATES.

Output:

• a string.

Related:

• `sboo-ghc-pragma-read-pragma'.
• `sboo-ghc-pragmas-alist'."

  (interactive)

  (completing-read (format "%s: " prompt)
                   candidates))

;;----------------------------------------------;;

(defun sboo-ghc-pragma-read-pragma ()

  "Read a GHC pragma.

Related:

• `sboo-ghc-pragmas-alist'."

  (interactive)

  (let ((prompt     "Pragma")
        (candidates sboo-ghc-pragmas)
        )

    (completing-read (format "%s: " prompt)
                     candidates)))

;;----------------------------------------------;;

(defun sboo-ghc-pragma-insert-pragma (&optional pragma)

  "Insert a GHC pragma, reading it if PRAGMA is nil.

Related:

• `sboo-ghc-pragma-read-pragma'."

  (interactive (list
                (sboo-ghc-pragma-read-pragma)))

  (let* ((STRING (format "{-# %s #-}" pragma))
         )

    (insert STRING "\n")))

;;----------------------------------------------;;

(defalias 'sboo-ghc-read-WARNING    #'sboo-ghc-read-string)
(defalias 'sboo-ghc-read-DEPRECATED #'sboo-ghc-read-string)

;;----------------------------------------------;;
sboo-ghc-get-names-of-definitions-current-file
;;----------------------------------------------;;
(defmacro sboo-move-to-head-of-alist! (key alist)

  "Move KEY and its value to the `car' of ALIST.

Inputs:

• KEY — is one of: `symbolp', `stringp', or `numberp'.

• ALIST — is an `alist' variable. 
          its key-type is equal to the `type-of' KEY.

Output:

• an `alist'.

• ALIST is mutated too."

  `(setq ,variable (append ,list ,variable)))

;;----------------------------------------------;;

(cl-defun sboo-submodule-directory (package-name &key version)
  "Return « \"`sboo-submodule-directory'/`PACKAGE-NAME-VERSION'\" ».

Examples:

• M-: (add-to-list 'load-path (sboo-submodule-directory \"use-package\")
    ⇒ \"/home/sboo/.emacs.d/submodules/use-package/\"

• M-: (add-to-list 'load-path (sboo-submodule-directory \"use-package\" :version \"2.3\")
    ⇒ \"/home/sboo/.emacs.d/submodules/use-package-2.3/\"

Links:

• URL `https://git-scm.com/book/en/v2/Git-Tools-Submodules'.
• URL `https://chrisjean.com/git-submodules-adding-using-removing-and-updating/'."

  (let* ((PackageDirectoryPrefix (concat sboo-vendored-package-directory package-name))

	 (VersionSuffix          (if version
	                             (format "-%s" version)
                                   ""))

	 (PackageDirectory (file-name-as-directory
                            (concat PackageDirectoryPrefix VersionSuffix)))
         )

    PackageDirectory))

;;----------------------------------------------;;

TODO

  (use-package dante
     :load-path (sboo-submodule-directory "dante")

;; Error (use-package): Failed to parse package dante: Symbol’s value as variable is void: sboo-submodule-directory


;;----------------------------------------------;;

(cl-defun sboo-deep-copy-alist (alist)

  "Copy ALIST deeply (i.e. recursively).

Inputs:

• ALIST — is an `alist'.

Output:

• an `alist' with the same keys and values as ALIST."

  (mapcar #'copy-sequence alist))

;;----------------------------------------------;;

(use-package lisp-mode

  :init

  ()

  :bind (:map lisp-mode-map
              ("[" . sboo-insert-open-parenthesis)
              ("]" . sboo-insert-close-parenthesis)
              ("(" . sboo-insert-open-square-bracket)
              (")" . sboo-insert-close-square-bracket)
              )

  :config 

  ())

;;----------------------------------------------;;

(use-package lisp-mode

  :init

  ()

  :bind (:map lisp-mode-map
              ("[" . sboo-insert-open-parenthesis)
              ("]" . sboo-insert-close-parenthesis)
              ("(" . sboo-insert-open-square-bracket)
              (")" . sboo-insert-close-square-bracket)
              )

  :config 

  ())

;;----------------------------------------------;;


    (when sboo-dante-method-default
      (setq dante-methods-alist
            (sboo-move-to-head-of-alist dante-methods-alist :key sboo-dante-method-default)))

;;----------------------------------------------;;

  (defun sboo-edit-indirect-guess-mode (parent-buffer parent-region-begin parent-region-end)

    "Guess the major mode for an edit-indirect buffer.

Calls `set-auto-mode', which parses the « mode » file-local (special) variable 
(i.e. « -*- mode: ... -*- »)."

    (set-auto-mode t)

    (if-let* (
              )

        ()

      (prog-mode)))

;;----------------------------------------------;;


(defun sboo-read-character-name-via-collection ()

  "Read a Unicode character name, returning the string `NAME'.

Haskell Type « :: IO String ».

See `ucs-names'."

  (completing-read "Unicode character name: " sboo-unicode-names-list nil t))

;;----------------------------------------------;;

(defun sboo-annotate-character-name-with-character-literal (name)

  "Annotate `NAME' (e.g. \"BULLET\") with the char itself (e.g. ?•).

Haskell Type « :: String -> String ».
"
  ;TODO(throw 'sboo NAME)

  (let ((CHAR
         (gethash name sboo-unicode-names-hash-table)))

    (if CHAR
        (let ((PRINTABLE
               t)) ;;TODO check 'general-category for whether character is printable (or is control)

          (if PRINTABLE
              (let ((ANNOTATED
                     (format-message "%s  %s" (char-to-string CHAR) name)))
              ;; (let ((ANNOTATION
              ;;        (format-message " %s" (char-to-string CHAR))))

                ANNOTATED)
            name)))))

;;----------------------------------------------;;

(defun sboo-read-character-name-with-annotations ()

  "Read a Unicode character name, returning the string `NAME'.

Annotates each completion candidate with the unicode character being named.

Haskell Type « :: IO String ».

Calls `completing-read' with Info node ‘(elisp)Programmed Completion’"

  (let ((completion-extra-properties
         '(:annotation-function sboo-annotate-character-name-with-character-literal)))

    (completing-read "Unicode character name: " sboo-unicode-names-hash-table nil t)))

;; ^
;;     M-: (message (sboo-read-character-name-with-annotations))

;;----------------------------------------------;;

(defun sboo-read-character-with-literals-displayed ()

  "Read a Unicode character name, returning the string `NAME'.

Prepends each completion candidate with the unicode character being named
(which must then be stripped back out).

Haskell Type « :: IO String ».

Calls `completing-read' with ‘(elisp)Programmed Completion’"

  (let* ((COMPLETION
          (completing-read "Unicode character (char & name): " sboo-unicode-completion-descriptions-hash-table nil t))
         (CHAR
          (gethash COMPLETION sboo-unicode-completion-descriptions-hash-table)))

    CHAR))

;; ^
;;     M-: (message (sboo-read-character-with-literals-displayed))

;;----------------------------------------------;;

(cl-defun sboo-read-character (&key method display)

  "Read a Unicode character name, returning the string `NAME'.

Inputs:

• NAME    — a `stringp'. The name of the unicode character.
• DISPLAY — a `booleanp'. Whether to display the unicode character itself (beside the name).

Wraps `sboo-read-character-with-literals-displayed', `sboo-read-character-name-with-annotations', `sboo-read-character-name-via-collection'."

  (let ((CHAR-READER
         (if METHOD METHOD #'sboo-read-character-with-literals-displayed))) ;TODO shorter aliases (than full names) in keywords).

    (call-interactively CHAR-READER)))

;;TODO function (not command) alias?
;; (defalias sboo-read-character-name #'sboo-read-character-name-with-annotations)













;;----------------------------------------------;;

(defun sboo-get-unicode-names-list ()

  "Construct `sboo-unicode-names-list'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  (hash-table-keys ucs-names))

  ;; (let ((NAMES '()))

  ;;   (progn
  ;;     (cl-flet ((ADD-CHAR-NAME (CHAR PROPERTIES)
  ;;                              (add-to-list 'NAMES (aget PROPERTIES 'name)))) ;TODO

  ;;       (map-char-table #'ADD-CHAR-NAME
  ;;                       char-code-property-table))

  ;;     NAMES)))

;;----------------------------------------------;;

(defun sboo-get-unicode-names-hash-table ()

  "Construct `sboo-unicode-names-hash-table'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  ucs-names)

;;----------------------------------------------;;

(defun sboo-get-unicode-completion-description-hash-table ()

  "Construct `sboo-unicode-completion-descriptions-hash-table'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  ucs-names

  )








;;;###autoload
(defvar sboo-unicode-names-list (sboo-get-unicode-names-list)

  "The list of each Unicode character's (unique) `name'.

Haskell Type « :: [String] ».

[TODO ordered list?]

[TODO « Map Char String »]

e.g...

    M-: (consp (member \"BULLET\" sboo-unicode-names-list))
    t

")

;;----------------------------------------------;;

;;;###autoload
(defvar sboo-unicode-names-hash-table (sboo-get-unicode-names-hash-table)

  "The mapping from each Unicode character `name' to its character.

Equals `ucs-names'.

Haskell Type « :: Map Char String ».

Examples:

    M-: (gethash \"BULLET\" sboo-unicode-names-hash-table)
    ?•
")

;; M-: (gethash "BULLET" ucs-names)

;;----------------------------------------------;;

;;;###autoload
(defvar sboo-unicode-completion-descriptions-hash-table (sboo-get-unicode-completion-description-hash-table)

  "The mapping from each Unicode character `name' to a description thereof.

This description combines the name of the character with said character being named.
In particular, each table-key is a Unicode Character Codepoint (the table-value) 
prepended to its Unicode Character Name (with a space).
For example, one entry is:

    (:key   \"• BULLET\"
     :value ?•
    )

Provides caching for completion.

NOTE Why does this exist when `sboo-unicode-names-hash-table' does too? 
Because currently (circa 2018), `helm' doesn't support the `:annotation-function' property of `completion-extra-properties'.

Derived from `ucs-names'.

Haskell Type « :: Map String Char ».

Examples:

    M-: (gethash \"• BULLET\" sboo-unicode-completion-descriptions-hash-table)
    ?•

    M-: (gethash \"BULLET\" sboo-unicode-completion-descriptions-hash-table)
    nil

    M-: (gethash \"•\" sboo-unicode-completion-descriptions-hash-table)
    nil")

;; ^
;;     M-: (gethash "• BULLET" sboo-unicode-completion-descriptions-hash-table)
;;     ?•







(cl-defun sboo/alist->table (alist &key test size)

  "Create a Hash Table from ALIST.

Inputs:

• ALIST — an association `listp'. 
• TEST  — a `symbolp' (naming a `functionp'). See `make-hash-table'.
• SIZE  — an `integerp'. See `make-hash-table'.

Output:

• a `hash-table-p' with the same entries as ALIST (modulo duplicate keys).

Example:

• M-: (sboo/alist->table '((x . 1) (y . 2)) :test #'eq :size 3)
    ⇒ #s(hash-table size 3 test eq data (x 1 y 2))
"

  (let* ((TEST  (or test
                    #'equal))

         (SIZE  (or size
                    (length alist)))

         (TABLE (make-hash-table :test TEST :size SIZE))

         )

    (progn

      (mapc #'add-entry alist)

      TABLE)))



(defun sboo-ucs-names-get (name)

  "Get the Unicode Character whose name is NAME.

Inputs:

• NAME — a `stringp'.
  The name of a Unicode Character.

Output:

• an `integerp'.
  a Unicode Character codepoint.

Type (Haskell):

• « :: String -> Maybe Char »

Example:

• M-: (format \"%c\" (sboo-ucs-names-get \"BULLET\"))
    ⇒ \"•\"
• M-: (sboo-ucs-names-get \"NOT A UNINCODE CHARACTER NAME\")
    ⇒ nil
"

  (let* ((NAME   (upcase name))
         (OBJECT (sboo-ucs-names-table))
         (TYPE   (type-of OBJECT))
         (CHAR   (pcase TYPE
                   ('hash-table (gethash NAME OBJECT))
                   ('list       (alist-get NAME OBJECT nil nil #'equal))
                   (_           nil)))
         )

    CHAR))

;; ^ (format "%c" (sboo-ucs-names-get "BULLET"))

;;----------------------------------------------;;


;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

