;;; -*- lexical-binding: t -*-

;;==============================================;;
;;; Commentary:

;; Completion for Unicode Character Names.
;;
;; • `sboo-ucs-names-table' — the primary Unicode data structure.
;; • `sboo-read-character-name' — the primary completion function.
;;
;; 

;;==============================================;;
;;; Code:

;;----------------------------------------------;;
;; Imports -------------------------------------;;
;;----------------------------------------------;;

;; Builtins:

(require 'cl)     ;; "CommonLisp"
(require 'subr-x) ;; "SUBRoutine-eXtRAS"
(require 'mule)   ;; "MUltiLingual Environment"

;;----------------------------------------------;;
;; Variables -----------------------------------;;
;;----------------------------------------------;;

(defvar sboo-ucs-names-table

  nil

  "Hash-Table from Unicode Character names to Unicode Character codepoints.

« ucs » abbreviates « Unicode CharacterS(?) ».

Examples:

• M-: (message \"%c\" (gethash \"LATIN SMALL LETTER ALPHA\" sboo-ucs-names-table))
    ⇒ \"ɑ\"

Accessed by Function `sboo-ucs-names-table'.")

;;----------------------------------------------;;

(defvar sboo-ucs-names-list

  nil

  "List of Unicode Character names.

Examples:

• M-: (nth 891 sboo-ucs-names-list)
    ⇒ \"LATIN SMALL LETTER ALPHA\"

Related:

• `sboo-unicode--'

Accessed by Function `sboo-ucs-names-list'.")

;;----------------------------------------------;;

(defvar sboo-ucs-names-interesting-list

  nil

  "List of Unicode Character names, filtering away “boring” characters (like ASCII).

Related:

• `sboo-unicode--interesting-character-p'")

;;----------------------------------------------;;

(defvar sboo-ucs-names-annotated-list

  nil

  "List of Unicode Character names, annotated with their namesake-characters.

Examples:

• M-: (nth 891 sboo-ucs-names-annotated-list)
    ⇒ \"ɑ LATIN SMALL LETTER ALPHA\"

Related:

• `sboo-unicode--annotate-character-p'

Displayed by Function `sboo-read-character-name'.

Like `sboo-ucs-names-list', but each name is prefixed by the namesake character (plus a space).")

;;----------------------------------------------;;

(defcustom sboo-unicode-completion-annotate

  t

  "Whether to display the unicode character itself (beside the name), during completion.

Type:

• a `booleanp'.

Related:

• `sboo-read-character-by-name'.

For example, `sboo-unicode-completion-annotate' toggles whether `sboo-read-character-by-name' displays:

• \"LATIN SMALL LETTER ALPHA\"   (if nil)
• \"ɑ LATIN SMALL LETTER ALPHA\" (if t)"

  :type '(boolean)

  :safe  t
  :group 'sboo)

;;----------------------------------------------;;

(defcustom sboo-unicode-completion-namesake-divider

  "  "

  "Divider between a character and its name, in `sboo-read-character-name' (a `stringp')."

  :type '(choice (string  :tag "Literal text")
                 (integer :tag "Number of spaces")
                 (const nil :tag "No divider")) ;TODO or "Fallback to default"?

  ;;:set ;TODO set dirty flag (property?)

  :safe  t
  :group 'sboo)

;;----------------------------------------------;;
;; Functions: Accessors ------------------------;;
;;----------------------------------------------;;

(cl-defun sboo-ucs-names-table (&key refresh)

  "Return a mapping of Unicode Character names to Unicode Character codepoints.

Initializes Variable `sboo-ucs-names-table'.

Inputs:

• REFRESH — a `booleanp'.
  If non-nil, rebuild Variable `sboo-ucs-names-table' from `ucs-names'
  (even if they've already been initialized to a non-nil `hash-table-p').

Output:

• a `hash-table-p' from `stringp's to `integerp's.

Examples:

• M-: (sboo-ucs-names-table :refresh t)
    ⇒ #s(hash-table size 42943 test equal rehash-size 1.5 rehash-threshold 0.8125 data (\"NULL\" 0 ... ))

Related:

• `ucs-names'

Notes:

• `ucs-names' is a `hash-table-p' on Emacs≥26 and an alist on Emacs≤25."

  (progn

    ;; Initialize:

    (when (or refresh
              (not sboo-ucs-names-table))

      (let* ((OBJECT (ucs-names))
             (TYPE   (type-of OBJECT))
             (TABLE  (pcase TYPE
                       ('hash-table OBJECT)
                       ('list       (sboo/alist->table OBJECT :test #'equal :size 43000))
                       (_           nil)))
             )

        (setq sboo-ucs-names-table TABLE)))
    
    ;; Access:

    sboo-ucs-names-table))

;;----------------------------------------------;;

(cl-defun sboo-ucs-names-list (&key refresh annotate)

  "Return all Unicode Character names.

Inputs:

• REFRESH — a `booleanp'.
  If non-nil, rebuild the « sboo-ucs-names-* » variables
  (i.e. Variable `sboo-ucs-names-list', Variable `sboo-ucs-names-annotated-list')
  from `ucs-names', even if they've already been initialized (to a non-nil `listp').
• ANNOTATE — a `booleanp'.
  Whether to return Variable `sboo-ucs-names-list' or Variable `sboo-ucs-names-annotated-list'.

Output:

• a `listp' of `stringp's.

Examples:

• M-: (sboo-ucs-names-list)
    ⇒ (\"NULL\" ... \"BULLET\" ...)

• M-: (sboo-ucs-names-list :annotate t)
    ⇒ (\"  NULL\" ... \"• BULLET\" ...)

Related:

• `ucs-names'

Notes:

• `ucs-names' is a `hash-table-p' on Emacs≥26 and an alist on Emacs≤25."

  (progn

    ;; Initialize:

    (when (or refresh
              (not (and sboo-ucs-names-list
                        sboo-ucs-names-annotated-list)))

      (let* ((TABLE (sboo-ucs-names-table :refresh refresh))
             (NAMES (hash-table-keys TABLE))
             )

        (progn

          (setq sboo-ucs-names-list NAMES)

          (setq sboo-ucs-names-annotated-list
                (mapcar #'sboo-unicode--prefix-namesake-character NAMES)))))

    ;; Access:

    (if annotate
        sboo-ucs-names-annotated-list
      sboo-ucs-names-list)))

;;----------------------------------------------;;

(defun sboo-unicode-completion-namesake-divider-string ()

  "Accessor for Variable `sboo-unicode-completion-namesake-divider'.

Output:

• a `stringp'."

  (let* ((OBJECT sboo-unicode-completion-namesake-divider)
         )

  (pcase OBJECT

    ((pred stringp)  OBJECT)
    ((pred integerp) (make-string OBJECT ?\ ))
    ('nil            nil)

    (_ " "))))

;; ^ NOTE «  ?\  » is a space literal character.

;;----------------------------------------------;;

(defun sboo-unicode-completion-namesake-divider-length ()

  "Accessor for Variable `sboo-unicode-completion-namesake-divider'.

Output:

• an `integerp'."

  (let* ((OBJECT sboo-unicode-completion-namesake-divider)
         )

  (pcase OBJECT

    ((pred stringp)  (length OBJECT))
    ((pred integerp) OBJECT)
    ('nil            nil)

    (_ 1))))

;;----------------------------------------------;;
;; Functions -----------------------------------;;
;;----------------------------------------------;;

(defun sboo-ucs-names-get (name)

  "Get the Unicode Character whose name is NAME.

Inputs:

• NAME — a `stringp'.
  The name of a Unicode Character.

Output:

• an `integerp'.
  a Unicode Character codepoint.

Type (Haskell):

• « :: String -> Maybe Char »

Example:

• M-: (format \"%c\" (sboo-ucs-names-get \"BULLET\"))
    ⇒ \"•\"
• M-: (sboo-ucs-names-get \"NOT A UNINCODE CHARACTER NAME\")
    ⇒ nil"

  (let* ((NAME  (upcase name))
         (TABLE (sboo-ucs-names-table))
         (CHAR  (gethash NAME TABLE))
         )

    CHAR))

;; ^ (format "%c" (sboo-ucs-names-get "BULLET"))

;;----------------------------------------------;;

(defun sboo-get-char-name (char)

  "Get the Unicode Character Database « 'name » of CHAR.

Inputs:

• CHAR — a character (an `integerp').

Examples:

    M-: (call-interactively #'sboo-get-char-name)
    Character: c
    ⇒ \"LATIN SMALL LETTER C\"

Related:

• `get-char-code-property'."

  (interactive (list
                (or (condition-case _
                        (sboo-unicode--interesting-character-p (thing-at-point 'char))
                      (error nil))
                    (condition-case _
                        (read-char-exclusive "Character (press a key): ")
                                        ;TODO read 1-length string.
                      (error nil))
                    )))

  (get-char-code-property char 'name))

;;----------------------------------------------;;
;; Commands ------------------------------------;;
;;----------------------------------------------;;

(defun sboo-read-character-name (&optional annotate refresh)

  "Read a Unicode Character name.

Inputs: Keyword Arguments are passed-through to `sboo-ucs-names-list'.

Output:

• a `stringp'.
  a key of `ucs-names'.

Type (Haskell):

• « :: IO String ».

Related:

• `ucs-names'."

  (interactive (list nil
                     (if current-prefix-arg t nil)
                     ))

  (let*  ((ANNOTATE      (or annotate sboo-unicode-completion-annotate))

          (PROMPT        (format "%s: " "Unicode Character name"))
          (REQUIRE-MATCH t)
          (PREDICATE     nil)
          (HISTORY       nil)
          (CANDIDATES    (sboo-ucs-names-list :annotate ANNOTATE :refresh refresh))
          )

    (let* ((STRING (let ((completion-ignore-case t))
                     (completing-read PROMPT CANDIDATES PREDICATE REQUIRE-MATCH nil HISTORY nil nil)))

           (NAME   (if ANNOTATE
                       (sboo-unicode--strip-namesake-character STRING)
                     STRING))
           )

      (string-trim-left NAME))))

;; ^ NOTE `string-trim-left' will trim a `sboo-unicode-completion-namesake-divider' any length.

;;----------------------------------------------;;

(defun sboo-read-character-by-name ()

  "Read a Unicode Character name, returning the corresponding Unicode Character.

Output:

• an `integerp' (a character).
  a value of `ucs-names'.

Type (Haskell):

• « :: IO Char ».

Related:

• `ucs-names'.
• `read-character-by-name' — doesn't support fuzzy-matching."

  (interactive (list
                (if current-prefix-arg t nil)
                ))

  (let* ((STRING (sboo-read-character-name))
         (CHAR   (sboo-ucs-names-get STRING))
         )

    CHAR))

;;----------------------------------------------;;

;;TODO;(cl-defun sboo-insert-unicode-name (name &key display-properties)

(defun sboo-insert-unicode-name ()

  "Read and insert a Unicode Character name.

Output:

• a `stringp'.
  The Unicode Character name that was read and inserted.
  nil if that character didn't satisfy `sboo-unicode--insertable-character-p'.

Type (Haskell):

• « :: IO String ».

Related:

• `sboo-read-character-name'."

  (interactive)

  (let ((STRING (sboo-read-character-name))
        (NAME   (upcase STRING))
        )

    (insert STRING)))

;; M-x (call-interactively #'sboo-insert-unicode-name)

;;----------------------------------------------;;

;;TODO;(cl-defun sboo-insert-char (name &key display-properties)

(defun sboo-insert-char (name)

  "Insert the Unicode Character named `NAME'.

Inputs:

• NAME — a `stringp'. 
         The name of a Unicode Character.

Type (Haskell):

• « :: String -> IO () ».

Notes:

• `sboo-insert-char' is like `insert-char', but:

    • its completion is more flexible (for example, `helm' can be configured to efficiently fuzzily-match)
    • it displays the literal unicode character itself alongside each name (when `sboo-unicode-completion-annotate' is non-nil).

Related:

• `sboo-unicode-completion-annotate'.
• `sboo-read-character-name'.
• `sboo-ucs-names-get'."

  (interactive (list (sboo-read-character-name)
                     ))

  (let* ((NAME name)
         (CHAR (sboo-ucs-names-get NAME))
         )

    (pcase CHAR

      ('nil              nil)
      ((pred stringp)    (insert      CHAR))
      ((pred characterp) (insert-char CHAR))

      (_ (error "sboo-insert-char")))))

;; M-x (call-interactively #'sboo-insert-char) 

;;----------------------------------------------;;
;; Utilities -----------------------------------;;
;;----------------------------------------------;;

(cl-defun sboo-unicode--prefix-namesake-character (name)

  "Prefix NAME with the character it names.

Inputs:

• NAME — a `stringp'. The name of the unicode character.

Output:

• a `stringp'. 
  the output `length' will always be exactly two more than the input's.

Some characters aren't displayed, including:

• non-printable characters (e.g. NULL)
• ascii characters (e.g. LATIN SMALL LETTER A)

Examples:

    M-: (sboo-unicode--prefix-namesake-character \"BULLET\")
      ⇒ \"•  BULLET\"

    M-: (sboo-unicode--prefix-namesake-character \"SKULL\")
      ⇒ \"💀  SKULL\"

    M-: (sboo-unicode--prefix-namesake-character \"NULL\")
      ⇒ \"   NULL\"

    M-: (equal (substring (sboo-unicode--prefix-namesake-character \"NULL\") (sboo-unicode-completion-namesake-divider-length)) \"NULL\")
      ⇒ t

    M-: (= (sboo-unicode-completion-namesake-divider-length) (- (length (sboo-unicode--prefix-namesake-character \"NULL\")) (length \"NULL\"))
      ⇒ t"

  (let* ((CHAR    (sboo-ucs-names-get name))
         (DIV     (sboo-unicode-completion-namesake-divider-string))
         )

    (if DIV

        (let* ((STRING (if (and CHAR (sboo-unicode--annotate-character-p CHAR))
                           (char-to-string CHAR)
                         " "))
               )
          (concat STRING DIV name))

      (char-to-string CHAR))))

;; « C-x C-e » Tests:
;;
;; (sboo-unicode--prefix-namesake-character "SKULL")
;; (sboo-unicode--prefix-namesake-character "LATIN SMALL LETTER ALPHA")
;; (sboo-unicode--prefix-namesake-character "")
;;
;; (sboo-unicode--prefix-namesake-character "NULL")
;; (sboo-unicode--prefix-namesake-character "DIGIT ZERO")
;; (sboo-unicode--prefix-namesake-character "LATIN SMALL LETTER A")
;;

;;----------------------------------------------;;

(cl-defun sboo-unicode--annotate-character-p (char &key )

  "Whether `sboo-read-character' should annotate CHAR.

Inputs:

• CHAR — an `integerp'.
  A Unicode Character codepoint.

Output:

• a `booleanp'. 

Some characters can't be displayed (or shouldn't be annotated), including:

• Non-printable characters (e.g. NULL)
• Alphanumeric ASCII characters (e.g. LATIN SMALL LETTER A)

Examples:

    M-: (sboo-unicode--annotate-character-p ?💀)
      ⇒ t

    M-: (sboo-unicode--annotate-character-p ?-)
      ⇒ t

    M-: (sboo-unicode--annotate-character-p 0)
      ⇒ nil

    M-: (sboo-unicode--annotate-character-p ?0)
      ⇒ nil

    M-: (sboo-unicode--annotate-character-p ?a)
      ⇒ nil

    M-: (sboo-unicode--annotate-character-p ?Z)
      ⇒ nil

Links:

• URL `https://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html'"

  (let* ((UNPRINTABLE?        (< char 32))  ;TODO what about unprintables in higher-ranges? or surrogates?
         (ASCII-ALPHANUMERIC? (or (and (>= char ?0) (<= char ?9))
                                  (and (>= char ?A) (<= char ?Z))
                                  (and (>= char ?a) (<= char ?z))
                                  ))
         )

    (and (not UNPRINTABLE?)
         (not ASCII-ALPHANUMERIC?)
         )))

;;----------------------------------------------;;

(cl-defun sboo-unicode--insertable-character-p (char &key )

  "Whether `sboo-insert-char' can `insert' CHAR.

Inputs:

• CHAR — an `integerp'.
  A Unicode Character codepoint.

Output:

• a `booleanp'.

Some characters can't be inserted, including:

• Surrogates (e.g. TODO)

Links:

• URL `'"

  t)

;;----------------------------------------------;;

(defun sboo-unicode--strip-namesake-character (string)

  "Invert `sboo-unicode--prefix-namesake-character'.

Inputs:

• STRING — a `stringp'.

Output:

• a `stringp'. 

Examples:

    M-: (sboo-unicode--strip-namesake-character (sboo-unicode--prefix-namesake-character \"BULLET\"))
      ⇒ \"BULLET\"

Related:

• `sboo-unicode-completion-namesake-divider'"

  (let* ((LENGTH (sboo-unicode-completion-namesake-divider-length))
         )

    (if LENGTH
        (substring string (+ 1 LENGTH))
      string)))

;; (sboo-unicode--strip-namesake-character (sboo-unicode--prefix-namesake-character "BULLET"))

;;----------------------------------------------;;

(defun sboo-unicode--interesting-character-p (char)

  "Whether CHAR is an “interesting” Unicode Character.

Inputs:

• CHAR — an `integerp'.

Output:

• a `booleanp'."

  (let* ((UNPRINTABLE?        (< char 32))  ;TODO what about unprintables in higher-ranges? or surrogates?
         (ASCII-ALPHANUMERIC? (or (and (>= char ?0) (<= char ?9))
                                  (and (>= char ?A) (<= char ?Z))
                                  (and (>= char ?a) (<= char ?z))
                                  ))
         )

    (and (not UNPRINTABLE?)
         (not ASCII-ALPHANUMERIC?)
         )))

;;----------------------------------------------;;

(cl-defun sboo/alist->table (alist &key test size)

  "Create a Hash Table from ALIST.

Inputs:

• ALIST — an association `listp'. 
• TEST  — a `symbolp' (naming a `functionp'). See `make-hash-table'.
• SIZE  — an `integerp'. See `make-hash-table'.

Output:

• a `hash-table-p' with the same entries as ALIST (modulo duplicate keys).

Example:

• M-: (sboo/alist->table '((x . 1) (y . 2)) :test #'eq :size 3)
    ⇒ #s(hash-table size 3 test eq data (x 1 y 2))"

  (let* ((TEST  (or test
                    #'equal))

         (SIZE  (or size
                    (length alist)))

         (TABLE (make-hash-table :test TEST :size SIZE))

         )

    (progn

      (dolist (ENTRY alist)
        (let ((k (car ENTRY))
              (v (cdr ENTRY))
              )
          (puthash k v TABLE)))

      TABLE)))

;;----------------------------------------------;;
;; Notes ---------------------------------------;;
;;----------------------------------------------;;

;;; DOCS ‘ucs-names’: [TODO]
;;
;; « ucs-names » :: « HashMap String Char »
;;
;;     M-: (type-of ucs-names)
;;     'hash-table
;;
;; Examples:
;;
;;     M-: (gethash "BULLET" ucs-names)
;;     8226
;;     
;;     M-: '(?•)
;;     '(8226)
;;
;;     M-: (type-of (gethash "BULLET" ucs-names))
;;     'integer
;; 
;;     M-: (member "BULLET" (hash-table-keys ucs-names))
;;     t
;;

;;; DOCS ‘get-char-code-property’:
;;
;; « (get-char-code-property CHAR PROPNAME) »
;;
;; > M-: (get-char-code-property ?• 'name)
;; > "BULLET"
;; > 
;; > M-: (type-of (get-char-code-property ?• 'name))
;; > 'string
;; > 
;; > M-: (type-of char-code-property-table)
;; > 'char-table
;;
;; NOTE a char-table is sparse and compact, so `aref' doesn't quite work: [TODO why not?]
;;
;;     M-: (aref char-code-property-table ?•)
;;     nil
;;
;;     M-: (char-table-range char-code-property-table ?•)
;;     nil
;; 
;;     M-: 
;;     
;;
;;

;;; DOCS `map-char-table':
;;
;; « (map-char-table FUNCTION CHAR-TABLE) »
;;
;; > This function calls its argument function for each element of char-table that has a non-nil value. The call to function is with two arguments, a key and a value. The key is a possible range argument for char-table-range—either a valid character or a cons cell (from . to), specifying a range of characters that share the same value. The value is what (char-table-range char-table key) returns.
;;
;; NOTE:
;; > Standard mapping functions like `mapcar` do not allow char-tables because a char-table is a sparse array whose nominal range of indices is very large.
;;

;;; DOCS `mapcar':
;;
;; « (mapcar FUNCTION SEQUENCE) »
;;
;; > Apply FUNCTION to each element of SEQUENCE, and make a list of the results.
;; > The result is a list just as long as SEQUENCE.
;; > SEQUENCE may be a list, a vector, a bool-vector, or a string.
;;

;;; DOCS `insert-char':
;;
;; > DEFUN ("insert-char", Finsert_char, Sinsert_char, 1, 3,
;; >        "(list (read-char-by-name \"Insert character (Unicode name or hex): \")\
;; >               (prefix-numeric-value current-prefix-arg)\
;; >               t))",
;; >        doc: /* Insert COUNT copies of CHARACTER.
;; > Interactively, prompt for CHARACTER.  You can specify CHARACTER in one
;; > of these ways:
;; >
;; >  - As its Unicode character name, e.g. \"LATIN SMALL LETTER A\".
;; >    Completion is available; if you type a substring of the name
;; >    preceded by an asterisk `*', Emacs shows all names which include
;; >    that substring, not necessarily at the beginning of the name.
;; >
;; >  - As a hexadecimal code point, e.g. 263A.  Note that code points in
;; >    Emacs are equivalent to Unicode up to 10FFFF (which is the limit of
;; >    the Unicode code space).
;; > 
;; >  - As a code point with a radix specified with #, e.g. #o21430
;; >    (octal), #x2318 (hex), or #10r8984 (decimal).
;; >
;; > If called interactively, COUNT is given by the prefix argument.  If
;; > omitted or nil, it defaults to 1.
;; > 

;; NOTE `completion-extra-properties':
;;
;; * :annotation-function
;; * :exit-function
;;
;; 

;;; DOCS `cl-flet':
;;
;; e.g.
;;
;;    (require 'cl)
;;    (cl-flet ((f (x) (* x x)))
;;      (f 7))
;;

;;; DOCS `char-to-string':
;;
;; e.g.
;;
;;    M-: (char-to-string ?•)
;;    "•"

;;; See:
;;
;; ./share/emacs/26.1/lisp/international/uni-name.el 
;; 

;;==============================================;;
(provide 'sboo-unicode)

;;----------------------------------------------;;

data XdgDirectory

  = XdgData
    -- ^ For data files (e.g. images).
    --   Defaults to @~\/.local\/share@ and can be
    --   overridden by the @XDG_DATA_HOME@ environment variable.
    --   On Windows, it is @%APPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Roaming@).
    --   Can be considered as the user-specific equivalent of @\/usr\/share@.

  | XdgConfig
    -- ^ For configuration files.
    --   Defaults to @~\/.config@ and can be
    --   overridden by the @XDG_CONFIG_HOME@ environment variable.
    --   On Windows, it is @%APPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Roaming@).
    --   Can be considered as the user-specific equivalent of @\/etc@.

  | XdgCache
    -- ^ For non-essential files (e.g. cache).
    --   Defaults to @~\/.cache@ and can be
    --   overridden by the @XDG_CACHE_HOME@ environment variable.
    --   On Windows, it is @%LOCALAPPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Local@).
    --   Can be considered as the user-specific equivalent of @\/var\/cache@.

;;----------------------------------------------;;

(pcase sboo-xdg-platform

  ('posix ())

  ('windows ())
  
  (_ ()))

;;----------------------------------------------;;


(cl-defun sboo-xdg-xyz (path &key subdir)

  "Make an xdg path for xyz files, from PATH.

Inputs:

• PATH   — a string. the suffix of the filepath to output.
• SUBDIR — a string. if non-nil (or absent), prefix PATH with SUBDIR.

Output: a string. \"$XDG_XYZ_HOME/SUBDIR/PATH\".

Example:

• M-: (sboo-xdg-xyz \"directory/basename.txt\")
      \"~/.directory/basename.txt\"

• M-: (sboo-xdg-xyz \"basename.txt\" :subdir \"directory\")
      \"~/.directory/basename.txt\"

« $XDG_XYZ_HOME » defaults to:

• « ~/.xyz » — on POSIX.
• «  » — on Windows.'

Use for (e.g. ).

See URL `https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html'.

Related:

• `sboo-xdg-xyz-default'
• `sboo-xdg-xyz-environment'"

  (let ((XdgPathEnvironment (getenv "XDG_XYZ_HOME"))
        (XdgPathDefault     "~/.xyz")
        (XdgPath            (if XdgPathEnvironment
                                XdgPathEnvironment
                              (file-name-as-directory XdgPathDefault)))
        (SubDirectory       (if subdir
                                (file-name-as-directory subdir)
                              ""))
        )

    (file-truename (cocnat XdgPath Subdir Path))))

;;----------------------------------------------;;


(defun sboo-next-buffer (count)
 
  "Move COUNT buffers 'forwards'.
"

  (interactive )

  (progn
  
    ()))

(defun sboo-prior-buffer (count)
 
  "Move COUNT buffers 'backwards'.
"

  (interactive )

  (progn
  
    ()))

;;----------------------------------------------;;

(defconst platform

  (cond                                 ;TODO pcase `(,system-type ,window-system)

   ((or (memq system-type   '(gnu/linux)))

    'platform-linux)

   ((or (memq system-type   '(cygwin windows-nt ms-dos))
        (memq window-system '(w32 pc)))

    'platform-windnows)

   ((or (memq system-type   '(darwin))
        (memq window-system '(mac ns)))

    'platform-apple)

   ((or (eq window-system 'x))  ;; TODO and Wayland?
    ;; ^ X11 runs on non-Linux operating-systems too (like Apple).

    'platform-linux)

   (t
    'platform-unknown))

  "The current platform, a symbol (prefixed with `platform-').

One of: 

* 'platform-linux
* 'platform-windows
* 'platform-apple
* 'platform-unknown

Depends on the variables `system-type' and `window-system'.")

;;----------------------------------------------;;

  (pcase `(,system-type . ,window-system)

    ( `( ,(or 'gnu/linux) . ,_ )

      'platform-linux)

    ( `( ,_ . ,_ )

      'platform-unknown))

;;----------------------------------------------;;

  (pcase (list system-type window-system)

    ( `(,(or 'gnu/linux) ,_)

      'platform-linux)

    ( ,_

      'platform-unknown))

  
;;----------------------------------------------;;
  (use-package dante
    :after    haskell

    :commands (dante-mode dante-restart)

    :bind (:map haskell-mode-map
                (("C-c d" . sboo-dante-mode)))

;;;  :hook ((haskell-mode . flycheck-mode)
;;;         (haskell-mode . dante-mode))

    :init
    (add-hook 'haskell-mode-hook #'flycheck-mode)
    (add-hook 'haskell-mode-hook #'dante-mode)

    :config
    (setq dante-repl-command-line-methods-alist
          sboo-dante-repl-command-line-methods-alist)

    (setq sboo-haskell-eldoc 'dante)

    (setq dante-tap-type-time 2)

    ())

;;----------------------------------------------;;

(defun sboo--ghc-pragma-read (prompt candidates)

  "Read a candidate from CANDIDATES.

Output:

• a string.

Related:

• `sboo-ghc-pragma-read-pragma'.
• `sboo-ghc-pragmas-alist'."

  (interactive)

  (completing-read (format "%s: " prompt)
                   candidates))

;;----------------------------------------------;;

(defun sboo-ghc-pragma-read-pragma ()

  "Read a GHC pragma.

Related:

• `sboo-ghc-pragmas-alist'."

  (interactive)

  (let ((prompt     "Pragma")
        (candidates sboo-ghc-pragmas)
        )

    (completing-read (format "%s: " prompt)
                     candidates)))

;;----------------------------------------------;;

(defun sboo-ghc-pragma-insert-pragma (&optional pragma)

  "Insert a GHC pragma, reading it if PRAGMA is nil.

Related:

• `sboo-ghc-pragma-read-pragma'."

  (interactive (list
                (sboo-ghc-pragma-read-pragma)))

  (let* ((STRING (format "{-# %s #-}" pragma))
         )

    (insert STRING "\n")))

;;----------------------------------------------;;

(defalias 'sboo-ghc-read-WARNING    #'sboo-ghc-read-string)
(defalias 'sboo-ghc-read-DEPRECATED #'sboo-ghc-read-string)

;;----------------------------------------------;;
sboo-ghc-get-names-of-definitions-current-file
;;----------------------------------------------;;
(defmacro sboo-move-to-head-of-alist! (key alist)

  "Move KEY and its value to the `car' of ALIST.

Inputs:

• KEY — is one of: `symbolp', `stringp', or `numberp'.

• ALIST — is an `alist' variable. 
          its key-type is equal to the `type-of' KEY.

Output:

• an `alist'.

• ALIST is mutated too."

  `(setq ,variable (append ,list ,variable)))

;;----------------------------------------------;;

(cl-defun sboo-submodule-directory (package-name &key version)
  "Return « \"`sboo-submodule-directory'/`PACKAGE-NAME-VERSION'\" ».

Examples:

• M-: (add-to-list 'load-path (sboo-submodule-directory \"use-package\")
    ⇒ \"/home/sboo/.emacs.d/submodules/use-package/\"

• M-: (add-to-list 'load-path (sboo-submodule-directory \"use-package\" :version \"2.3\")
    ⇒ \"/home/sboo/.emacs.d/submodules/use-package-2.3/\"

Links:

• URL `https://git-scm.com/book/en/v2/Git-Tools-Submodules'.
• URL `https://chrisjean.com/git-submodules-adding-using-removing-and-updating/'."

  (let* ((PackageDirectoryPrefix (concat sboo-vendored-package-directory package-name))

	 (VersionSuffix          (if version
	                             (format "-%s" version)
                                   ""))

	 (PackageDirectory (file-name-as-directory
                            (concat PackageDirectoryPrefix VersionSuffix)))
         )

    PackageDirectory))

;;----------------------------------------------;;

TODO

  (use-package dante
     :load-path (sboo-submodule-directory "dante")

;; Error (use-package): Failed to parse package dante: Symbol’s value as variable is void: sboo-submodule-directory


;;----------------------------------------------;;

(cl-defun sboo-deep-copy-alist (alist)

  "Copy ALIST deeply (i.e. recursively).

Inputs:

• ALIST — is an `alist'.

Output:

• an `alist' with the same keys and values as ALIST."

  (mapcar #'copy-sequence alist))

;;----------------------------------------------;;

(use-package lisp-mode

  :init

  ()

  :bind (:map lisp-mode-map
              ("[" . sboo-insert-open-parenthesis)
              ("]" . sboo-insert-close-parenthesis)
              ("(" . sboo-insert-open-square-bracket)
              (")" . sboo-insert-close-square-bracket)
              )

  :config 

  ())

;;----------------------------------------------;;

(use-package lisp-mode

  :init

  ()

  :bind (:map lisp-mode-map
              ("[" . sboo-insert-open-parenthesis)
              ("]" . sboo-insert-close-parenthesis)
              ("(" . sboo-insert-open-square-bracket)
              (")" . sboo-insert-close-square-bracket)
              )

  :config 

  ())

;;----------------------------------------------;;


    (when sboo-dante-method-default
      (setq dante-methods-alist
            (sboo-move-to-head-of-alist dante-methods-alist :key sboo-dante-method-default)))

;;----------------------------------------------;;

  (defun sboo-edit-indirect-guess-mode (parent-buffer parent-region-begin parent-region-end)

    "Guess the major mode for an edit-indirect buffer.

Calls `set-auto-mode', which parses the « mode » file-local (special) variable 
(i.e. « -*- mode: ... -*- »)."

    (set-auto-mode t)

    (if-let* (
              )

        ()

      (prog-mode)))

;;----------------------------------------------;;


(defun sboo-read-character-name-via-collection ()

  "Read a Unicode character name, returning the string `NAME'.

Haskell Type « :: IO String ».

See `ucs-names'."

  (completing-read "Unicode character name: " sboo-unicode-names-list nil t))

;;----------------------------------------------;;

(defun sboo-annotate-character-name-with-character-literal (name)

  "Annotate `NAME' (e.g. \"BULLET\") with the char itself (e.g. ?•).

Haskell Type « :: String -> String ».
"
  ;TODO(throw 'sboo NAME)

  (let ((CHAR
         (gethash name sboo-unicode-names-hash-table)))

    (if CHAR
        (let ((PRINTABLE
               t)) ;;TODO check 'general-category for whether character is printable (or is control)

          (if PRINTABLE
              (let ((ANNOTATED
                     (format-message "%s  %s" (char-to-string CHAR) name)))
              ;; (let ((ANNOTATION
              ;;        (format-message " %s" (char-to-string CHAR))))

                ANNOTATED)
            name)))))

;;----------------------------------------------;;

(defun sboo-read-character-name-with-annotations ()

  "Read a Unicode character name, returning the string `NAME'.

Annotates each completion candidate with the unicode character being named.

Haskell Type « :: IO String ».

Calls `completing-read' with Info node ‘(elisp)Programmed Completion’"

  (let ((completion-extra-properties
         '(:annotation-function sboo-annotate-character-name-with-character-literal)))

    (completing-read "Unicode character name: " sboo-unicode-names-hash-table nil t)))

;; ^
;;     M-: (message (sboo-read-character-name-with-annotations))

;;----------------------------------------------;;

(defun sboo-read-character-with-literals-displayed ()

  "Read a Unicode character name, returning the string `NAME'.

Prepends each completion candidate with the unicode character being named
(which must then be stripped back out).

Haskell Type « :: IO String ».

Calls `completing-read' with ‘(elisp)Programmed Completion’"

  (let* ((COMPLETION
          (completing-read "Unicode character (char & name): " sboo-unicode-completion-descriptions-hash-table nil t))
         (CHAR
          (gethash COMPLETION sboo-unicode-completion-descriptions-hash-table)))

    CHAR))

;; ^
;;     M-: (message (sboo-read-character-with-literals-displayed))

;;----------------------------------------------;;

(cl-defun sboo-read-character (&key method display)

  "Read a Unicode character name, returning the string `NAME'.

Inputs:

• NAME    — a `stringp'. The name of the unicode character.
• DISPLAY — a `booleanp'. Whether to display the unicode character itself (beside the name).

Wraps `sboo-read-character-with-literals-displayed', `sboo-read-character-name-with-annotations', `sboo-read-character-name-via-collection'."

  (let ((CHAR-READER
         (if METHOD METHOD #'sboo-read-character-with-literals-displayed))) ;TODO shorter aliases (than full names) in keywords).

    (call-interactively CHAR-READER)))

;;TODO function (not command) alias?
;; (defalias sboo-read-character-name #'sboo-read-character-name-with-annotations)













;;----------------------------------------------;;

(defun sboo-get-unicode-names-list ()

  "Construct `sboo-unicode-names-list'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  (hash-table-keys ucs-names))

  ;; (let ((NAMES '()))

  ;;   (progn
  ;;     (cl-flet ((ADD-CHAR-NAME (CHAR PROPERTIES)
  ;;                              (add-to-list 'NAMES (aget PROPERTIES 'name)))) ;TODO

  ;;       (map-char-table #'ADD-CHAR-NAME
  ;;                       char-code-property-table))

  ;;     NAMES)))

;;----------------------------------------------;;

(defun sboo-get-unicode-names-hash-table ()

  "Construct `sboo-unicode-names-hash-table'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  ucs-names)

;;----------------------------------------------;;

(defun sboo-get-unicode-completion-description-hash-table ()

  "Construct `sboo-unicode-completion-descriptions-hash-table'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  ucs-names

  )








;;;###autoload
(defvar sboo-unicode-names-list (sboo-get-unicode-names-list)

  "The list of each Unicode character's (unique) `name'.

Haskell Type « :: [String] ».

[TODO ordered list?]

[TODO « Map Char String »]

e.g...

    M-: (consp (member \"BULLET\" sboo-unicode-names-list))
    t

")

;;----------------------------------------------;;

;;;###autoload
(defvar sboo-unicode-names-hash-table (sboo-get-unicode-names-hash-table)

  "The mapping from each Unicode character `name' to its character.

Equals `ucs-names'.

Haskell Type « :: Map Char String ».

Examples:

    M-: (gethash \"BULLET\" sboo-unicode-names-hash-table)
    ?•
")

;; M-: (gethash "BULLET" ucs-names)

;;----------------------------------------------;;

;;;###autoload
(defvar sboo-unicode-completion-descriptions-hash-table (sboo-get-unicode-completion-description-hash-table)

  "The mapping from each Unicode character `name' to a description thereof.

This description combines the name of the character with said character being named.
In particular, each table-key is a Unicode Character Codepoint (the table-value) 
prepended to its Unicode Character Name (with a space).
For example, one entry is:

    (:key   \"• BULLET\"
     :value ?•
    )

Provides caching for completion.

NOTE Why does this exist when `sboo-unicode-names-hash-table' does too? 
Because currently (circa 2018), `helm' doesn't support the `:annotation-function' property of `completion-extra-properties'.

Derived from `ucs-names'.

Haskell Type « :: Map String Char ».

Examples:

    M-: (gethash \"• BULLET\" sboo-unicode-completion-descriptions-hash-table)
    ?•

    M-: (gethash \"BULLET\" sboo-unicode-completion-descriptions-hash-table)
    nil

    M-: (gethash \"•\" sboo-unicode-completion-descriptions-hash-table)
    nil")

;; ^
;;     M-: (gethash "• BULLET" sboo-unicode-completion-descriptions-hash-table)
;;     ?•







(cl-defun sboo/alist->table (alist &key test size)

  "Create a Hash Table from ALIST.

Inputs:

• ALIST — an association `listp'. 
• TEST  — a `symbolp' (naming a `functionp'). See `make-hash-table'.
• SIZE  — an `integerp'. See `make-hash-table'.

Output:

• a `hash-table-p' with the same entries as ALIST (modulo duplicate keys).

Example:

• M-: (sboo/alist->table '((x . 1) (y . 2)) :test #'eq :size 3)
    ⇒ #s(hash-table size 3 test eq data (x 1 y 2))
"

  (let* ((TEST  (or test
                    #'equal))

         (SIZE  (or size
                    (length alist)))

         (TABLE (make-hash-table :test TEST :size SIZE))

         )

    (progn

      (mapc #'add-entry alist)

      TABLE)))



(defun sboo-ucs-names-get (name)

  "Get the Unicode Character whose name is NAME.

Inputs:

• NAME — a `stringp'.
  The name of a Unicode Character.

Output:

• an `integerp'.
  a Unicode Character codepoint.

Type (Haskell):

• « :: String -> Maybe Char »

Example:

• M-: (format \"%c\" (sboo-ucs-names-get \"BULLET\"))
    ⇒ \"•\"
• M-: (sboo-ucs-names-get \"NOT A UNINCODE CHARACTER NAME\")
    ⇒ nil
"

  (let* ((NAME   (upcase name))
         (OBJECT (sboo-ucs-names-table))
         (TYPE   (type-of OBJECT))
         (CHAR   (pcase TYPE
                   ('hash-table (gethash NAME OBJECT))
                   ('list       (alist-get NAME OBJECT nil nil #'equal))
                   (_           nil)))
         )

    CHAR))

;; ^ (format "%c" (sboo-ucs-names-get "BULLET"))

;;----------------------------------------------;;

(require 'regexp-opt)
(require 'faces)
(require 'color)

;;----------------------------------------------;;

(cl-defun sboo-things (&key fast)

  "List all known things for `forward-thing'.

Inputs:

• FAST — a `booleanp'.

Output:

• a `listp' of `symbolp's.

Example:

• M-: (sboo-things :fast t)

Related:

• `sboo-things-builtin'
• `sboo-things-custom'
• `forward-thing'"

  (let* ((KNOWN-THINGS (append sboo-things-builtin sboo-things-custom))
         )

    (if fast
        KNOWN-THINGS

      (let* ((THINGS-VIA-SYMBOL-PROPERTY (mapatoms sboo-thing-by-property &optional obarray))
             (THINGS-VIA-FUNCTION-NAMES  (mapatoms sboo-thing-by-name     &optional obarray))

             (UNKNOWN-THINGS (append THINGS-VIA-FUNCTION-NAMES THINGS-VIA-SYMBOL-PROPERTY))
             )

        (append KNOWN-THINGS UNKNOWN-THINGS)))))

;;----------------------------------------------;;

• M-: (sboo-forward-ops)

    ⇒ (list #'forward-str #'forward-page #'forward-op #'forward-line #'forward-list #'forward-word #'forward-point #'forward-button #'forward-symbol #'forward-sentence #'forward-paragraph #'end-of-defun #'forward-char #'forward-comment #'forward-whitespace #'forward-thing #'forward-sexp)

    ⇒ (list #'forward-page #'forward-line #'forward-list #'forward-word #'forward-point #'forward-button #'forward-symbol #'forward-sentence #'forward-paragraph #'end-of-defun #'forward-char #'forward-comment ...))

;;----------------------------------------------;;

(cl-defun sboo-color-parse-json (&key file string)

  "Parse a json STRING or FILE, whose schema is a list of `sboo-color-name'.

Inputs:

• FILE — a « .json » file.
• STRING — a json string.

Output:

• a list of `sboo-color-name's.

Example:

• M-: (sboo-color-parse-json :string \"[{\\\"name\\\":\\\"1975 Earth Red\\\",\\\"hex\\\":\\\"#7a463a\\\"}]\")
    ⇒ [ ... ]

• M-: (sboo-color-parse-json :file \"colornames.json\")
    ⇒ [ ... ]

Links:

• URL `https://unpkg.com/color-name-list@3.64.0/dist/colornames.json"

  (let* ((JSON (if (stringp string)
                   string
                 (if (stringp file)
                     (read file)
                   (throw 'sboo-color-parse-json))))
         )

    (let* ((json-object-type 'hash-table)
           (json-array-type  'list)
           (json-key-type    'string)
           (TABLE            (json-read-file file)))

      TABLE)))

;; ^ e.g.:
;;
;; (sboo-color-parse-json :string "[{\"name\":\"1975 Earth Red\",\"hex\":\"#7a463a\"}]")
;; (sboo-color-parse-json :file   "colornames.json")
;;

;;----------------------------------------------;;

  (let* ((PLIST (plist-get property-list))
         )

    (make-mtg-card @PLIST)))

;;----------------------------------------------;;

  (let* ((SUBLIST   (copy-sequence sublist))
         (SUPERLIST (copy-sequence superlist))
         )

    (dolist (ITEM SUPERLIST)
      (when (member ITEM sublist)
        (push ITEM SUBLIST)))

    (append SUBLIST SUPERLIST)))

  (let* ((SUBLIST-COPY (copy-sequence sublist))
         (SUBLIST      nil)
         (SUPERLIST    nil)
         )

    (dolist (SUPER-ITEM superlist)
      (when (member ITEM sublist)
        (push ITEM SUBLIST)))

    (append SUBLIST SUPERLIST)))

         (COMPARE      (lambda (x y)
                         (let ((X-IN-SUBLIST (if (member x sublist) t nil))
                               (Y-IN-SUBLIST (if (member y sublist) t nil))
                               )
                           ())))

;;----------------------------------------------;;
# -*- mode: snippet -*-
#
# key         : sboo-insert
# name        : a « defun » wrapping sboo-insert-char.
# type        : snippet
# expand-env  : ((yas-indent-line 'auto) (yas-wrap-around-region 'nil))
# condition   : (let ((KEY "sboo-insert")) (condition-case nil (= (current-column) (string-width KEY)) (error t)))
#
# --
;;----------------------------------------------;;

(defun sboo-insert-${1:$(string-join (split-string (downcase yas-text)) "-")} ()
  "`insert' ?${1:$(ignore-errors (format "%c" (gethash yas-text (ucs-names))))}, the \\"${1:$$(progn (require 'mule) (require 'subr-x) (let ((CHAR-NAME (yas-choose-value (hash-table-keys (ucs-names))))) CHAR-NAME))}\\" Unicode character."
  (interactive)
  (insert-char ?${1:$(ignore-errors (format "%c" (gethash yas-text (ucs-names))))}))

$0

;;----------------------------------------------;;
(defun sboo-insert-{1:$$(progn (require 'mule) (require 'subr-x) (let ((CHAR-NAME (yas-choose-value (hash-table-keys (ucs-names))))) (string-join (split-string (downcase CHAR-NAME)) "-")))}
  "`insert' ?${1:$(format "%c" (gethash yas-text (ucs-names)))}, the \\"${1:$(string-join (split-string (upcase yas-text) "[-]+" :omit-nulls) " ")}\\" Unicode character."
  (interactive)
  (insert-char ?${1:$(format "%c" (gethash yas-text (ucs-names)))}))

$0
;;----------------------------------------------;;
(defun sboo-insert-${1:$$(progn (require 'mule) (require 'subr-x) (let ((CHAR-NAME (yas-choose-value (hash-table-keys (ucs-names))))) (string-join (split-string (downcase CHAR-NAME)) "-")))}
  "`insert' ?${1:$(format "%c" (gethash yas-text (ucs-names) ?α))}, the \\"${1:$(string-join (split-string (upcase yas-text) "[-]+" :omit-nulls) " ")}\\" Unicode character."
  (interactive)
  (insert-char ?${1:$(format "%c" (gethash yas-text (ucs-names) ?α))}))

$0
;;----------------------------------------------;;
(defcustom sboo-nix-build-file-regexp

  (rx " "
      "at" (group-n 1 (one-or-more (any "./~" "a-f" "A-F" "0-9")) ".nix")
      ":"  (group-n 2 (one-or-more digit))
      ":"  (group-n 3 (one-or-more digit))
      )

;;----------------------------------------------;;
(let* ((G-FILENAME 1)
       (G-LINE     2)
       (G-COLUMN   3)
       (REGEXP     (rx (group-n G-FILENAME (1+ (or "/~." letter digit)) ".nix")
                       (? ":" (group-n G-LINE (1+ digit))
                          (? ":" (group-n G-COLUMN (1+ digit)))))))

  (let ((STRING "~/default.nix:999:78"))

    (string-match REGEXP STRING)

    (list (match-string G-FILENAME STRING)
          (match-string G-LINE     STRING)
          (match-string G-COLUMN   STRING))))
;;----------------------------------------------;;


(defun sboo-use-package-init ()

  "Register and initialize `use-package'.

Links:

• URL `https://github.com/jwiegley/use-package'"

  (let* ()

    (progn

      (sboo-register-submodule-packages! "use-package")

      (progn
     ;; (eval-when-compile (require 'use-package))

        (eval-when-compile (add-to-list 'load-path (expand-file-name "~/.emacs.d/submodules/use-package/")))
        (eval-when-compile (require 'use-package (expand-file-name "~/.emacs.d/submodules/use-package/use-package.el")))

        (require 'diminish)
        (require 'bind-key)

        (setq use-package-verbose t)))))

;;----------------------------------------------;;

(defun yaml-mode-version ()
  "Display version of `yaml-mode'."
  (interactive)
  (message "yaml-mode %s" yaml-mode-version)
  yaml-mode-version)

;;;###autoload
(add-to-list 'auto-mode-alist '("\\.\\(e?ya?\\|ra\\)ml\\'" . yaml-mode))

;;----------------------------------------------;;

    
    (split-string text *separators* *omit-nulls* *separators*)))

;;----------------------------------------------;;

  (declare (side-effect-free t))

  (let ((*separators* "[ -/]+")
        (*omit-nulls* t)
        )

    (let* ((WORDS (split-string text split-string-default-separators t split-string-default-separators))
           )

      WORDS)))

;;----------------------------------------------;;
(cl-defun sboo-case-tokenize (text &key (steganograph nil))

  "Split TEXT into tokens.

Inputs:

• TEXT         — a `stringp'.
• STEGANOGRAPH — a `booleanp'. 
  (invisibly) `propertize' the output with the TEXT;
  this upgrades `sboo-case-tokenize' into a lossless transformation) helps other casing functions
  (e.g. `sboo-case-invert') preserve the original tokens (e.g. acronyms),
  including lossy transformations

Output:

• a `listp' of `stringp's.

Example:

• M-: (sboo-case-tokenize \"\")
    ⇒ '()

• M-: (sboo-case-tokenize \" two  words \" :steganograph nil)
    ⇒ '(\"two\" \"words\")

• M-: (sboo-case-tokenize \"two-words and/or sub_words\")
   ⇒ '(\"two\" \"-\" \"words\" \"and\" \"/\" \"or\" \"sub\" \"_\" \"words\")

Notes:

• By default, the tokens are words.

Related:

• `sboo-case-preserve-acronyms' (customizeable)"

  (declare (side-effect-free t))

  (let ((*separator-regex* "[_-/ \f\t\n\r\v]+")
        (*omit-nulls*      t)
        (*trim-regex*      "[ \f\t\n\r\v]+")
        )

    (let* ((WORDS (split-string text *separator-regex* *omit-nulls* *trim-regex*))
           )

      WORDS)))

;; M-: (sboo-case-tokenize " two  words " :steganograph nil)
;;  ⇒ '("two" "words")

;; M-: (sboo-case-tokenize "two-words and/or sub_words")
;;  ⇒ '("two" "-" "words" "and" "/" "or" "sub" "_" "words")

;; M-: (split-string "two-words and/or sub_words")
;;  ⇒ '("two-words" "and/or" "sub_words")

;;----------------------------------------------;;

(defun s-split (separator s &optional omit-nulls)
  "Split S into substrings bounded by matches for regexp SEPARATOR.
If OMIT-NULLS is non-nil, zero-length substrings are omitted.

This is a simple wrapper around the built-in `split-string'."
  (declare (side-effect-free t))
  (save-match-data
    (split-string s separator omit-nulls)))

(defun s-split-words (s)
  "Split S into list of words."
  (declare (side-effect-free t))
  (s-split
   "[^[:word:]0-9]+"
   (let ((case-fold-search nil))
     (replace-regexp-in-string
      "\\([[:lower:]]\\)\\([[:upper:]]\\)" "\\1 \\2"
      (replace-regexp-in-string "\\([[:upper:]]\\)\\([[:upper:]][0-9[:lower:]]\\)" "\\1 \\2" s)))
   t))

;;----------------------------------------------;;

emacs-try:

	SBOO_EMACS_DESKTOP_RESTORE_EAGER=10 SBOO_EMACS_DESKTOP_FILE=/tmp/.emacs.desktop $(Emacs) $(EmacsOptions) --debug-init

.PHONY: emacs-try

;;----------------------------------------------;;

emacs-try:

	$(shell SBOO_EMACS_DESKTOP_RESTORE_EAGER=10 SBOO_EMACS_DESKTOP_WRITE=0 $(Emacs) $(EmacsOptions) --debug-init)

.PHONY: emacs-try

;;----------------------------------------------;;

emacs-try: SBOO_EMACS_DESKTOP_RESTORE_EAGER = 10 SBOO_EMACS_DESKTOP_WRITE = 0

	$(Emacs) $(EmacsOptions) --debug-init

.PHONY: emacs-try

;;----------------------------------------------;;

  (when (and sboo-desktop-enable (null sboo-no-desktop-read-at-startup))
    (desktop-read)
    (desktop-save-mode +1))

;;----------------------------------------------;;

(defvar xmodmap-map nil
  "Local keymap for xmodmap buffers.")

(if xmodmap-map
  nil
  (let ((map (make-keymap)))
    (define-key map "\^c\^c" 'xmodmap-read-current-file)
    (define-key map "\^c\^h" 'xmodmap-man)
    (define-key map "\^c\^s" 'xmodmap-shell-command)
    (easy-menu-define
      xmodmap-easy-menu map
      "Menu for Xmodmap mode."
      '("Xmodmap"
	 ["Read current file" xmodmap-read-current-file t]
	 ["Start xmodmap command" xmodmap-shell-command t]
	 ["-" nil t]
	 ["Xmodmap manual page" xmodmap-man t]))
    (setq xmodmap-map map)))

;;----------------------------------------------;;

setxkbmap -option "ctrl:nocaps" || true

# ^ « ctrl:nocaps »: Use Caps Lock as Control key.

;;----------------------------------------------;;
if [ -x "$(command -v ${xbindkeys})" ] #TODO and if x11 is active
then

if   ! pgrep -x "xbindkeys" > /dev/null
then "${xbindkeys}" --poll-rc -f "${xbindkeysrc}" || true
fi

# ^ Start the « xbindkeys » daemon in the background.

# ^ « --poll-rc » means: reload the config whenever it changes.

# ^ « -f _ » means: load the given config ("rc") file.
# By default, the config is at « ~/.xbindkeysrc », 
# which we've overriden to be under (one of) « $XDG_CONFIG_DIRS ».

fi
;;----------------------------------------------;;

xmodmap   = ''${pkgs.xorg.xmodmap}/bin/xmodmap'';

#setxkbmap = ''${pkgs.xorg.xmodmap}/bin/setxkbmap'';

#xbindkeys = ''${pkgs.xbindkeys}/bin/xbindkeys'';

;;----------------------------------------------;;

(progn

  (add-to-list 'compilation-error-regexp-alist       
               'sboo-nix-build-compilation-error)
  
  (add-to-list 'compilation-error-regexp-alist-alist
               (list 'sboo-nix-build-compilation-error
                     sboo-nix-build-compilation-error-rx
                     sboo-nix-rx-filename
                     sboo-nix-rx-line
                     sboo-nix-rx-column
                     compilation-error-type
                     sboo-nix-hyperlink)))
;;----------------------------------------------;;
         (ALIST   (pcase (type-of 'alist)

                    ('symbol (symbol-value alist))
                    ('cons   alist)

                    (_ :this-keyword-represents-nil-but-isnt-a-listp)))
;;----------------------------------------------;;
  (run-with-idle-timer 5 nil #'sboo-unicode-init)
  

;;----------------------------------------------;;

(defcustom sboo-markdown-wrappers-alist

  '( "*"
   )

  "`wrap-region' “wrappers”.

Examples (each is equivalent):

• « ?* »
• « \"*\" »
• « '(\"*\") »
• « '(\"*\" \"*\") »
• « '(\"*\" \"*\" \"*\") »

Associates right-wrappers with 
a(n optionally distinct) left-wrapper and 
a(n optionally distinct) trigger-keys."

  :type '(alist :key-type   (string :tag "")
                :value-type (choice (const nil)
                                    (string :tag "value")))

  :safe #'listp
  :group 'sboo-html)

;;----------------------------------------------;;

(cl-defun sboo-markdown-wrap-region-entry (left &key right key)

  "Creates an “arglist” for `wrap-region-add-wrapper'."

  (let* ((KEY   (or key left))
         (LEFT  left)
         (RIGHT (or right left))
         (MODES sboo-markdown-modes-list)
         )

    (list LEFT RIGHT KEY MODES)))

;;----------------------------------------------;;

(defun sboo-haskell-hide-dante-buffers ()

  "Hide `dante-mode' popup (via `display-buffer-alist')."

  (interactive)

  (let ((display-buffer-alist sboo-dante-display-buffer #'display-buffer-no-window nil))))

;;----------------------------------------------;;

  :hook ((json-mode . (flycheck-mode
                       sboo-set-font-to-iosevka
                       )))

;;----------------------------------------------;;

(use-package json-mode

  ;; :disabled

  :mode (("\\.json\\'" . json-mode)
         )

  :hook ((json-mode . flycheck-mode)
         (json-mode . sboo-set-font-to-iosevka)
         )

  ;; ^ FlyCheck builds-in a « jsonlint » checker
  ;; ^ « jsonlint » is a JSON Linter.
  )

;;----------------------------------------------;;

(use-package yaml-mode

  :mode (("\\.yaml\\'" . yaml-mode)
         ("\\.yml\\'"  . yaml-mode)
         )

  :hook ((yaml-mode . sboo-set-font-to-iosevka)
         )
  )
;;----------------------------------------------;;

         (dolist (THING things)

           (let* ((TEXT   (thing-at-point THING))
                  (TEXT-P (and TEXT (funcall predicate TEXT)))
                  )

             (if TEXT-P
                 TEXT
               nil)))
;;----------------------------------------------;;

;; M-: (let ((choices '(white blue black red green))) (sboo-dwim-get :predicate (lambda (s) (let ((choice (intern s))) (memq choice choices))) :things '(char word line) :prompt nil :reader (completing-read "Color: " choices))) ; blue
;;----------------------------------------------;;

(cl-defun sboo-dwim-get-number ()

  "Do-What-I-Mean — get a number.

Output:

• a `numberp' or nil.

Related:

• Wraps `sboo-dwim-get'."

  (sboo-dwim-get :predicate (lambda (s) (let ((n (string-to-number s))) (and (numberp n) (/= n 0))))
                 :things    '(word char)
                 :prompt    "Number: "
                 :reader #'read-number
                 ))
                 
;;----------------------------------------------;;

(cl-defun sboo-dwim-get-enum-symbol (xs &key prompt predicate things reader)

  "Do-What-I-Mean — get a character.

Input:

• XS     — a `listp' of `symbolp's.
• PROMPT — an optional `stringp'.

Output:

• a `symbolp' or `nil'.
  a `member' of XS.

Related:

• Wraps `sboo-dwim-get'."

  (let* ((PROMPT    (or prompt
                        nil))

         (THINGS    (or things
                        '(char word line)))

         (READER    (or reader
                        (lambda (*PROMPT*)
                          (intern
                           (completing-read *PROMPT* choices)))))

         (MEMBER?   (lambda (s)
                      (let ((x (intern s)))
                        (memq x xs))))
         (PREDICATE (or (if (functionp predicate) predicate nil)
                        MEMBER?))
         )

  (sboo-dwim-get :predicate PREDICATE
                 :things    THINGS
                 :reader    READER
                 :prompt    PROMPT
                 )))
;;----------------------------------------------;;


                 (let* ((TEXT   (thing-at-point THING :no-text-properties))
                        (TEXT-P (and TEXT
                                     (funcall predicate TEXT)))
                        )
                   (if TEXT-P
                       TEXT
                     nil)))

;;----------------------------------------------;;
(cl-loop for THING in '(url email number filename symbol word)
         
         (cl-let ((TEXT (thing-at-point THING :no-text-properties)))

           (when TEXT
             (return (cons THING TEXT)))))

;; ^ the **first** thing at point. 
;;----------------------------------------------;;

import qualified "${1:egg}" ${2:$(progn (require 'subr-x) (with-temp-buffer (insert (yas-field-value 1)) (goto-char (point-min)) (while (< (point) (point-max)) (capitalize-word +1)) (string-trim (buffer-substring-no-properties (point-min) (point-max)))))} as ${3:$(progn (require 'subr-x) (with-temp-buffer (insert (yas-field-value 1)) (goto-char (point-min)) (while (< (point) (point-max)) (capitalize-word +1)) (string-trim (buffer-substring-no-properties (point-min) (point-max)))))}
$0

;;----------------------------------------------;;
import qualified "${1:egg}" ${1:$(ignore-errors (require 'subr-x) (with-temp-buffer (insert yas-text) (goto-char (point-min)) (while (< (point) (point-max)) (capitalize-word +1)) (string-trim (buffer-substring-no-properties (point-min) (point-max)))))} as ${1:$(ignore-errors (require 'subr-x) (with-temp-buffer (insert yas-text) (goto-char (point-min)) (while (< (point) (point-max)) (capitalize-word +1)) (string-trim (buffer-substring-no-properties (point-min) (point-max)))))}
$0
;;----------------------------------------------;;
pMTG :: ( MTGParsing p ) => Text -> p a -> JSON.Object -> JSON.Parser a
pMTG fieldName parser o = _

;;----------------------------------------------;;

pMTG :: ( Parse a, Default a ) => Text -> JSON.Object -> JSON.Parser a
pMTG fieldName o = JSON. fieldName parse def o

;;----------------------------------------------;;

pMTG :: ( Parse a, Default a ) => Text -> JSON.Object -> JSON.Parser a
pMTG fieldName o =

  (JSON.explicitParseFieldMaybe p o fieldName) .!= def

  where

  p = toParseJSON parse
;;----------------------------------------------;;

{- | Instantiate a @TokenParsing@ parser (from @parsers@) as a @Parser@ parser (from @attoparsec@),
for @aeson@. -}

toParseJSON :: ( MTG.MTGParsing p ) => p a -> AttoparsecParser a
toParseJSON = _

;;----------------------------------------------;;

(defcustom sboo-${1:name}-char

  ${2:nil}

  "$0.

a `characterp'."

  :type '(choice (const nil :tag "Default")
                 (character :tag "Character"))

  :safe #'characterp
  :group 'sboo)


;;----------------------------------------------;;

(defcustom sboo-comment-default-infix-char

  ?-

  "The default comment character.

a `characterp'."

  :type '(character :tag "Character")

  :safe #'characterp
  :group 'sboo-comment)

;;----------------------------------------------;;

sboo-comment-default-char ⇒ sboo-comment-default-prefix-char
sboo-comment-default-infix-char ⇒ sboo-comment-default-h1-infix-char
sboo-comment-default-infix-char ⇒ sboo-comment-default-h2-infix-char
 
;;----------------------------------------------;;

 (FILENAME (file-name-nondirectory (buffer-file-name)))
 (FEATURE  (file-name-sans-extension (file-name-nondirectory (buffer-file-name))))
 (MODE     (string-remove-suffix "-mode" (file-name-sans-extension (file-name-nondirectory (buffer-file-name))))))

;;----------------------------------------------;;

(defun $1-version (&optional show-version)

  "Display string describing the version of BNF Mode.

If called interactively or if SHOW-VERSION is non-nil, show the
version in the Echo Area and the Messages Buffer.

The returned string includes both, the version from package.el
and the library version, if both are present and different.

If the version number could not be determined, signal an error
if called interactively or if SHOW-VERSION is non-nil, otherwise
just return nil."

  (interactive (list t))

  (let ((VERSION (pkg-info-version-info '$1))
        )

    (when show-version
      (message "Version of $1 (currently-\`load'ed): %s" VERSION))
    VERSION))
;;----------------------------------------------;;
(ignore-errors (with-temp-buffer (insert "Example Header") (downcase-region (point-min) (point-max)) (let* ((replace-char-fold t)) (replace-string " " "-" (point-min) (point-max)) (buffer-substring-no-properties (point-min) (point-max))))
;;----------------------------------------------;;

(defun sboo-custom-groups-list ()

  "Get all Customization Groups.

Output:

• a `listp' of `symbolp's.
  Everything defined by `defgroup'.
  An average `length' is 75. 

Notes:

• `defgroup' sets the `custom-group' property of the `symbolp')."

  (let* ((GROUPS )
         )

    (mapatoms (lambda (*SYMBOL*)
                (let ((GROUP (get *SYMBOL* 'custom-group))
                      )
                  (when GROUP
                    (push *SYMBOL* GROUPS)))))
    GROUPS))

;;----------------------------------------------;;

(defun sboo-read-custom-group ()

  "Read a Customization Group (from the user).

Output:

• a `symbolp'.
  a Customization Group (defined via `defgroup').

Notes:

• `defgroup' sets the `custom-group' property of the `symbolp')."

  (interactive)

  (let* ((CANDIDATES (sboo-custom-groups-list))
         (STRING     (completing-read "Customization Group: " CANDIDATES nil 'confirm "sboo-"))
         (SYMBOL     (intern-soft STRING))
         )

    SYMBOL))
;;----------------------------------------------;;

(progn

  ;;--------------------------;;
  
  (use-package spaceline

    :config

    (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main))))

    ())

  ;;--------------------------;;
  
  (use-package spaceline-config

    :config

    (spaceline-helm-mode +1)
    (spaceline-emacs-theme)

    ())

  ;;--------------------------;;
  
  ())
  
;; `http://amitp.blogspot.com/2017/01/emacs-spaceline-mode-line.html'

;;----------------------------------------------;;

  (setq markdown-command "multimarkdown")


;;----------------------------------------------;;

(use-package emacs

  :delight

  (visual-line-mode " VL")
  ;; ^ Shorten `visual-line-mode'.

  (auto-fill-function " aF")
  ;; ^ Shorten `auto-fill-mode'.

  )

;;----------------------------------------------;;

(use-package autorevert

  :delight

  (auto-revert-mode " aR")
  ;; ^ Shorten `auto-revert-modee'.

  )

;;----------------------------------------------;;

(use-package face-remap

  :delight

  (buffer-face-mode)
  ;; ^ Hide `buffer-face-mode'.

  )

;;----------------------------------------------;;
Note that when using a symbol or a function to provide a dynamically generated list of paths, you must inform the byte-compiler of this definition so the value is available at byte-compilation time. This is done by using the special form eval-and-compile (as opposed to eval-when-compile). Further, this value is fixed at whatever was determined during compilation, to avoid looking up the same information again on each startup:

(eval-and-compile
  (defun ess-site-load-path ()
    (shell-command "find ~ -path ess/lisp")))

(use-package ess-site
  :load-path (lambda () (list (ess-site-load-path)))
  :commands R)

;;----------------------------------------------;;
(defun magnars/rgrep-fullscreen (regexp &optional files dir confirm)

  "Open grep in full screen, saving windows."

  (interactive
   (progn
     (grep-compute-defaults)
     (cond
      ((and grep-find-command (equal current-prefix-arg '(16)))
       (list (read-from-minibuffer "Run: " grep-find-command
                                   nil nil 'grep-find-history)))
      ((not grep-find-template)
       (error "grep.el: No `grep-find-template' available"))
      (t (let* ((regexp (grep-read-regexp))
                (files (grep-read-files regexp))
                (dir (ido-read-directory-name "Base directory: "
                                              nil default-directory t))
                (confirm (equal current-prefix-arg '(4))))
           (list regexp files dir confirm))))))

  (window-configuration-to-register ?$)
  (rgrep regexp files dir confirm)
  (switch-to-buffer "*grep*")
  (delete-other-windows)
  (beginning-of-buffer))
;;----------------------------------------------;;
(defun markdown--style-map-prompt ()
  "Return a formatted prompt for Markdown markup insertion."
  (when markdown-enable-prefix-prompts
    (concat
     "Markdown: "
     (propertize "bold" 'face 'markdown-bold-face) ", "
     (propertize "italic" 'face 'markdown-italic-face) ", "
     (propertize "code" 'face 'markdown-inline-code-face) ", "
     (propertize "C = GFM code" 'face 'markdown-code-face) ", "
     (propertize "pre" 'face 'markdown-pre-face) ", "
     (propertize "footnote" 'face 'markdown-footnote-text-face) ", "
     (propertize "q = blockquote" 'face 'markdown-blockquote-face) ", "
     (propertize "h & 1-6 = heading" 'face 'markdown-header-face) ", "
     (propertize "- = hr" 'face 'markdown-hr-face) ", "
     "C-h = more")))

(defun markdown--command-map-prompt ()
  "Return prompt for Markdown buffer-wide commands."
  (when markdown-enable-prefix-prompts
    (concat
     "Command: "
     (propertize "m" 'face 'markdown-bold-face) "arkdown, "
     (propertize "p" 'face 'markdown-bold-face) "review, "
     (propertize "o" 'face 'markdown-bold-face) "pen, "
     (propertize "e" 'face 'markdown-bold-face) "xport, "
     "export & pre" (propertize "v" 'face 'markdown-bold-face) "iew, "
     (propertize "c" 'face 'markdown-bold-face) "heck refs, "
     (propertize "u" 'face 'markdown-bold-face) "nused refs, "
     "C-h = more")))


;;----------------------------------------------;;
(defun sboo-haskell--has-cabal-file-p (file)

  "Is FILE a « .cabal » file?"

  (string-match-p ".\\.cabal\\'" file))

;;----------------------------------------------;;

(cl-defun sboo-haskell-get-compilation-search-paths (&key root)

  "Extra `compilation-search-path's, given project-directory ROOT.

Inputs:

• ROOT — a `stringp'.
  Defaults to `sboo-haskell-guess-project-root'.

Output:

• a `stringp'."

  (let* ((ROOT (or root
                   (sboo-haskell-guess-project-root)))

         (SUBDIRECTORIES (directory-files ROOT)) ; TODO All (recursive) subdirectories, of the project root directory, with a « .cabal » file. directory-files-recursively directory regexp &optional include-directories
         )

    SUBDIRECTORIES))

;;----------------------------------------------;;
(cl-defun sboo-haskell-set-compile-command (&key buffer)

  "Set `compile-command' to to `sboo-haskell-get-compile-command'.

See:

• `sboo-haskell-set-compile-command'"

  (let* ((COMPILE-COMMAND (sboo-haskell-get-compile-command :buffer buffer))
         (COMPILE-PATHS   (sboo-haskell-get-compilation-search-paths))
         )

    (setq-local compile-command COMPILE-COMMAND)

    ;;TODO mv to `compile' hook, conditioned on haskell:
    ;;  (setq-local compilation-search-path (append compilation-search-path COMPILE-PATHS))

    ()))

;;----------------------------------------------;;

(cl-defun sboo-haskell-set-compilation-search-path (&key buffer)

  "Extend `compilation-search-path' (with subdirectories which have a Haskell package).

See:

• `sboo-haskell-get-compilation-search-paths'"

  (interactive (list
                (current-buffer)
                ))

  (let* ((COMPILE-PATHS (sboo-haskell-get-compilation-search-paths))
        )

    (setq-local compilation-search-path (append compilation-search-path COMPILE-PATHS))

    compilation-search-path))


;;==============================================;;

(define-key special-event-map [sigusr1] #'keyboard-quit)

;; ^ Handle a `sigusr1' event.

;;----------------------------------------------;;

(progn

  ;;--------------------------;;

  (defun sboo-handle-sigusr2 ()
    "Handle a `sigusr2' event.

Example (triggering):

  $ kill -SIGUSR2 $(pgrep emacs)

Related:

• `special-event-map'"

  (interactive)

  (let* ((EVENT last-input-event)
        )
    (message "Caught « SIGUSR2 » signal: « %S »" EVENT)))

  ;;--------------------------;;

  (define-key special-event-map [sigusr2] #'sboo-handle-sigusr2))

;;==============================================;;

(global-set-key (kbd "s-y") #'helm-show-kill-ring)        ; super "Yank"

;;----------------------------------------------;;

(global-set-key (kbd "s-p") #'compile)                    ; "comPile"

;;----------------------------------------------;;

;;==============================================;;

(cl-typecase sboo-insert
                      (command " (Com)")
                      (class   " (Class)")
                      (generic " (Gen)")
                      (fbound  " (Fun)")
                      (bound   " (Var)")
                      (face    " (Face)"))

(defvar-local sboo-insert

  "nil"

  "For `sboo-insert'.")

(setq-local sboo-insert #'sgml)

;;----------------------------------------------;;

(defun sboo-insert ()

  "Context-Sensitive `insert'."

  (interactive)

  (if (bound-and-true-p sboo-insert)
      (cl-typecase ( sboo-insert)

        (command (call-interactively sboo-insert))

        (function (funcall sboo-insert))

        (string (insert sboo-insert))

        (t ()))
    (message "`sboo-insert' not locally-defined.")))


(defun sboo-insert ()

  "Context-Sensitive `insert'."

  (interactive)

  (if (bound-and-true-p sboo-insert)
      (let* ((VALUE (symbol-value 'sboo-insert))
             )
        (cl-typecase VALUE

          (command (call-interactively VALUE))

          (function (funcall VALUE))

          ;;(symbol (... (symbol-value VALUE)))

          (string (insert VALUE))

          (t ())))
    (message "`sboo-insert' not locally-defined.")))

;;==============================================;;
(defun sboo-syntax/char-entry-p (entry)

  "Return t if ENTRY is: a `characterp's; or a `consp' of `characterp's."

  (or ()
      ()))

;;----------------------------------------------;;

(defun sboo-syntax/char-entry-p (entry)

  "Return t if ENTRY is: a `characterp's; or a `consp' of `characterp's."

  (pcase entry

    (`(,x . ,y) (and (characterp x) (characterp y)))
    (x (characterp x))

    (_ f)))
    
;;----------------------------------------------;;

(cl-defun sboo-syntax-add-bracket-entries (brackets &key syntax-table)

  "Register each pair of bracket characters with `sboo-syntax-add-bracket-entry'.

Input:

• BRACKETS — a `listp'.
  each entry is either: a `consp' (c.f. an Association List) of `characterp's; or a `characterp' (which is interpreted as a pair of that same character duplicated).
• SYNTAX-TABLE — an optional `char-table-p'.
  a syntax table.

Examples:

• M-: (sboo-syntax-add-bracket-entries '((?< . ?>) (?« . ?»)) :syntax-table standard-syntax-table)"

  (cl-assert (sboo-syntax/list-of-chars-or-char-cons-p brackets) t)
  (cl-assert (sboo-syntax/optional-char-table-p syntax-table) t)

  (let* ((SYNTAX-DESCRIPTION-OPENING (string ?\( closing))
         (SYNTAX-DESCRIPTION-CLOSING (string ?\) opening))
         )

    (dolist (PAIR brackets)
       (let* ((OPENING ())  
        (CLOSING ())
        )
       (sboo-syntax-add-bracket-entry OPENING CLOSING :syntax-table syntax-table))))

      (or syntax-table (syntax-table)))

;;----------------------------------------------;;
;;; `minibuffer-local-filename-completion-map'

(dolist (*MAP* (list minibuffer-local-filename-completion-map
                     minibuffer-local-completion-map
                     minibuffer-local-must-match-map

                     helm-find-files-map
                     ))

  (define-key *MAP* (kbd "<kp-left>")  #'backward-char)
  (define-key *MAP* (kbd "<kp-right>") #'forward-char)

  ())


;;----------------------------------------------;;

# name        : [sboo] a « define-derived-mode » file (a major mode), « *-mode.el ».

;;----------------------------------------------;;

finder-by-keyword
https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Keywords.html

;;----------------------------------------------;;
define-generic-mode
;;----------------------------------------------;;
(ignore-errors

  (when (>= emacs-major-version 24)

    (add-to-theme-path! sboo-theme-directory)
    (add-to-theme-path! (emacs-subdir "themes"))

    (progn
      (sboo-register-submodule-packages! "solarized")
      (sboo-register-submodule-themes!   "solarized")
      (load-theme 'solarized :no-confirm))

    ()))
;;----------------------------------------------;;
(insert (propertize "\"" 'font-lock-face 'font-lock-string-face))"
;;----------------------------------------------;;

(defun sboo-insert-font-lock-string-face (text)

  (let* ((TEXT-ESCAPED     (concat "\"" (text) "\""))
         (TEXT-PROPERTIZED (propertize TEXT-ESCAPED
                                       'font-lock-face 'font-lock-string-face))
        )

    (insert TEXT-PROPERTIZED)))
;;----------------------------------------------;;

;;----------------------------------------------;;

(defun sboo-os-current-system ()

  "The current platform, for XDG.

Output:

• a `symbolp'. One of:

    • 'linux   — for Linux (and/or X11).
    • 'windows — for Windows (and/or WIN32).
    • 'macos   — for OSX (and/or Cocoa).

Uses:

• `window-system'
• `system-type'"

  (cond

   ((or (memq system-type   '(gnu/linux)))
    'linux)

   ((or (memq system-type   '(windows-nt ms-dos))
        (memq window-system '(w32 pc)))
    'windows)

   ((or (memq system-type   '(darwin))
        (memq window-system '(mac ns)))
    'macos)

   (t
    nil)))

;;----------------------------------------------;;
# expand-env  : ((yas-indent-line 'fixed) (yas-wrap-around-region 'nil) (sboo-yas-file-base-name (file-name-base (buffer-file-name))))
;;----------------------------------------------;;
(defun sboo-shell-command-buffer (command)

  "Capture `shell-command' output in `help-mode' buffer.

Input:

• COMMAND — a `stringp'.
  a Command Invocation 
  (i.e. both the program name and the program arguments as a single line).

Examples:

• M-x sboo-shell-command-buffer 
  RET \"echo 'example'\"
  RET

Links:

• URL `https://jakemccrary.com/blog/2013/08/10/emacs-capture-shell-command-output-in-temporary-buffer/'"

  (interactive "s$ ")

  (let* ((PROGRAM     ( command))
         (BUFFER-NAME (format "*Help: %s*" PROGRAM))
         )

  (with-output-to-temp-buffer BUFFER-NAME
    (shell-command command
                   BUFFER-NAME
                   "*Messages*")
    (pop-to-buffer BUFFER-NAME))

  BUFFER-NAME))

;;----------------------------------------------;;

(defface ${1:language}-${2:syntax}-face

  '((t :inherit font-lock-$2-face))

  "Face for $2s."

  :group '$1-faces)

##################################################


;;----------------------------------------------;;
;; Syntax --------------------------------------;;
;;----------------------------------------------;;

(defvar expresso--char-syntax-symbols

  '((161 . 169) 172 (174 . 177) 180 (182 . 184) 191 215 247
    (706 . 709) (722 . 735) (741 . 747) 749 (751 . 767) 885
    894 (900 . 901) 903 1014 1154 (1370 . 1375) (1417 . 1418)
    (1421 . 1423) 1470 1472 1475 1478 (1523 . 1524) (1542 . 1551)
    1563 (1566 . 1567) (1642 . 1645) 1748 1758 1769 (1789 . 1790)
    (1792 . 1805) (2038 . 2041) (2096 . 2110) 2142 (2404 . 2405)
    2416 (2546 . 2547) (2554 . 2555) (2800 . 2801) 2928
    (3059 . 3066) 3199 3449 3572 3647 3663 (3674 . 3675)
    (3841 . 3863) (3866 . 3871) 3892 3894 3896 3973 (4030 . 4037)
    (4039 . 4044) (4046 . 4058) (4170 . 4175) (4254 . 4255)
    4347 (4960 . 4968) (5008 . 5017) 5120 (5741 . 5742)
    (5867 . 5869) (5941 . 5942) (6100 . 6102) (6104 . 6107)
    (6144 . 6154) 6464 (6468 . 6469) (6622 . 6623) (6624 . 6655)
    (6686 . 6687) (6816 . 6822) (6824 . 6829) (7002 . 7018)
    (7028 . 7036) (7164 . 7167) (7227 . 7231) (7294 . 7295)
    (7360 . 7367) 7379 8125 (8127 . 8129) (8141 . 8143)
    (8157 . 8159) (8173 . 8175) (8189 . 8190) (8208 . 8215)
    (8224 . 8231) (8240 . 8248) (8251 . 8260) (8263 . 8286)
    (8314 . 8316) (8330 . 8332) (8352 . 8381) (8448 . 8449)
    (8451 . 8454) (8456 . 8457) 8468 (8470 . 8472) (8478 . 8483)
    8485 8487 8489 8494 (8506 . 8507) (8512 . 8516) (8522 . 8525)
    8527 (8592 . 8703) (8704 . 8959) (8960 . 8967) (8972 . 9000)
    (9003 . 9210) (9216 . 9254) (9280 . 9290) (9372 . 9449)
    (9472 . 9599) (9600 . 9631) (9632 . 9727) (9728 . 9983)
    (9984 . 10087) (10132 . 10175) (10176 . 10180) (10183 . 10213)
    (10224 . 10239) (10240 . 10495) (10496 . 10623) (10624 . 10626)
    (10649 . 10711) (10716 . 10747) (10750 . 10751) (10752 . 11007)
    (11008 . 11123) (11126 . 11157) (11160 . 11193) (11197 . 11208)
    (11210 . 11217) (11493 . 11498) (11513 . 11516) (11518 . 11519)
    11632 (11776 . 11777) (11782 . 11784) 11787 (11790 . 11803)
    (11806 . 11807) (11818 . 11822) (11824 . 11841) (11904 . 11929)
    (11931 . 12019) (12032 . 12245) (12272 . 12283) (12289 . 12292)
    (12306 . 12307) 12316 12320 12336 (12342 . 12343)
    (12349 . 12351) (12443 . 12444) 12448 12539 (12688 . 12689)
    (12694 . 12703) (12736 . 12771) (12800 . 12830) (12842 . 12871)
    12880 (12896 . 12927) (12938 . 12976) (12992 . 13054)
    (13056 . 13311) (19904 . 19967) (42128 . 42182) (42238 . 42239)
    (42509 . 42511) 42611 42622 (42738 . 42743) (42752 . 42774)
    (42784 . 42785) (42889 . 42890) (43048 . 43051) (43062 . 43065)
    (43124 . 43127) (43214 . 43215) (43256 . 43258) (43310 . 43311)
    43359 (43457 . 43469) (43486 . 43487) (43612 . 43615)
    (43639 . 43641) (43742 . 43743) (43760 . 43761) 43867
    44011 64297 (64434 . 64449) (65020 . 65021) (65040 . 65046)
    65049 (65072 . 65076) (65093 . 65094) (65097 . 65103)
    (65104 . 65106) (65108 . 65112) (65119 . 65126) (65128 . 65131)
    (65281 . 65287) (65290 . 65295) (65306 . 65312) 65340
    (65342 . 65344) 65372 65374 65377 (65380 . 65381)
    (65504 . 65510) (65512 . 65518) (65532 . 65533) (65792 . 65794)
    (65847 . 65855) (65913 . 65929) 65932 (65936 . 65947)
    65952 (66000 . 66044) 66463 66512 66927 67671 (67703 . 67704)
    67871 67903 (68176 . 68184) 68223 68296 (68336 . 68342)
    (68409 . 68415) (68505 . 68508) (69703 . 69709) (69819 . 69820)
    (69822 . 69825) (69952 . 69955) (70004 . 70005) (70085 . 70088)
    70093 (70200 . 70205) 70854 (71105 . 71113) (71233 . 71235)
    (74864 . 74868) (92782 . 92783) 92917 (92983 . 92991)
    (92996 . 92997) 113820 113823 (118784 . 119029) (119040 . 119078)
    (119081 . 119140) (119146 . 119148) (119171 . 119172)
    (119180 . 119209) (119214 . 119261) (119296 . 119361)
    119365 (119552 . 119638) 120513 120539 120571 120597
    120629 120655 120687 120713 120745 120771 (126704 . 126705)
    (126976 . 127019) (127024 . 127123) (127136 . 127150)
    (127153 . 127167) (127169 . 127183) (127185 . 127221)
    (127248 . 127278) (127280 . 127339) (127344 . 127386)
    (127462 . 127487) (127488 . 127490) (127504 . 127546)
    (127552 . 127560) (127568 . 127569) (127744 . 127788)
    (127792 . 127869) (127872 . 127950) (127956 . 127991)
    (128000 . 128254) (128256 . 128330) (128336 . 128377)
    (128379 . 128419) (128421 . 128511) (128512 . 128578)
    (128581 . 128591) (128592 . 128639) (128640 . 128719)
    (128736 . 128748) (128752 . 128755) (128768 . 128883)
    (128896 . 128980) (129024 . 129035) (129040 . 129095)
    (129104 . 129113) (129120 . 129159) (129168 . 129197)))

(defvar expresso--char-syntax-identifiers
  '(170
    (178 . 179) 181 (185 . 186) (188 . 190) (192 . 214) (216 . 246)
    (248 . 255) (256 . 383) (384 . 591) (592 . 687) (880 . 883)
    (886 . 887) (891 . 893) 895 902 (904 . 906) 908 (910 . 929) (931 . 1013)
    (1015 . 1023) (1024 . 1153) (1162 . 1279) (1280 . 1327)
    (1329 . 1366) (1377 . 1415) (1488 . 1514) (1520 . 1522) (1568 . 1599)
    (1601 . 1610) (1632 . 1641) (1646 . 1647) (1649 . 1747) 1749
    (1774 . 1788) 1791 1808 (1810 . 1839) (1869 . 1871) (1872 . 1919)
    (1920 . 1957) 1969 (1984 . 2026) (2048 . 2069) (2112 . 2136) (2208 . 2226)
    (2308 . 2361) 2365 2384 (2392 . 2401) (2406 . 2415) (2418 . 2431)
    2432 (2437 . 2444) (2447 . 2448) (2451 . 2472) (2474 . 2480)
    2482 (2486 . 2489) 2493 2510 (2524 . 2525) (2527 . 2529) (2534 . 2545)
    (2548 . 2553) (2565 . 2570) (2575 . 2576) (2579 . 2600)
    (2602 . 2608) (2610 . 2611) (2613 . 2614) (2616 . 2617) (2649 . 2652)
    2654 (2662 . 2671) (2674 . 2676) (2693 . 2701) (2703 . 2705)
    (2707 . 2728) (2730 . 2736) (2738 . 2739) (2741 . 2745) 2749 2768
    (2784 . 2785) (2790 . 2799) (2821 . 2828) (2831 . 2832) (2835 . 2856)
    (2858 . 2864) (2866 . 2867) (2869 . 2873) 2877 (2908 . 2909)
    (2911 . 2913) (2918 . 2927) (2929 . 2935) 2947 (2949 . 2954) (2958 . 2960)
    (2962 . 2965) (2969 . 2970) 2972 (2974 . 2975) (2979 . 2980)
    (2984 . 2986) (2990 . 3001) 3024 (3046 . 3058) (3077 . 3084) (3086 . 3088)
    (3090 . 3112) (3114 . 3129) 3133 (3160 . 3161) (3168 . 3169)
    (3174 . 3183) (3192 . 3198) (3205 . 3212) (3214 . 3216) (3218 . 3240)
    (3242 . 3251) (3253 . 3257) 3261 3294 (3296 . 3297) (3302 . 3311)
    (3313 . 3314) (3333 . 3340) (3342 . 3344) (3346 . 3386) 3389
    3406 (3424 . 3425) (3430 . 3445) (3450 . 3455) (3461 . 3478) (3482 . 3505)
    (3507 . 3515) 3517 (3520 . 3526) (3558 . 3567) (3585 . 3632)
    (3634 . 3635) (3648 . 3653) (3664 . 3673) (3713 . 3714) 3716 (3719 . 3720)
    3722 3725 (3732 . 3735) (3737 . 3743) (3745 . 3747) 3749
    3751 (3754 . 3755) (3757 . 3760) (3762 . 3763) 3773 (3776 . 3780)
    (3792 . 3801) (3804 . 3807) 3840 (3872 . 3891) (3904 . 3911) (3913 . 3948)
    (3976 . 3980) (4096 . 4138) (4159 . 4169) (4176 . 4181)
    (4186 . 4189) 4193 (4197 . 4198) (4206 . 4208) (4213 . 4225) 4238
    (4240 . 4249) (4256 . 4293) 4295 4301 (4304 . 4346) (4349 . 4351)
    (4352 . 4607) (4608 . 4680) (4682 . 4685) (4688 . 4694) 4696 (4698 . 4701)
    (4704 . 4744) (4746 . 4749) (4752 . 4784) (4786 . 4789)
    (4792 . 4798) 4800 (4802 . 4805) (4808 . 4822) (4824 . 4880) (4882 . 4885)
    (4888 . 4954) (4969 . 4988) (4992 . 5007) (5024 . 5108)
    (5121 . 5740) (5743 . 5759) (5761 . 5786) (5792 . 5866) (5873 . 5880)
    (5888 . 5900) (5902 . 5905) (5920 . 5937) (5952 . 5969)
    (5984 . 5996) (5998 . 6000) (6016 . 6067) 6108 (6112 . 6121) (6128 . 6137)
    (6160 . 6169) (6176 . 6210) (6212 . 6263) (6272 . 6312) 6314
    (6320 . 6389) (6400 . 6430) (6470 . 6479) (6480 . 6509) (6512 . 6516)
    (6528 . 6571) (6593 . 6599) (6608 . 6618) (6656 . 6678)
    (6688 . 6740) (6784 . 6793) (6800 . 6809) (6917 . 6963) (6981 . 6987)
    (6992 . 7001) (7043 . 7072) (7086 . 7103) (7104 . 7141)
    (7168 . 7203) (7232 . 7241) (7245 . 7247) (7248 . 7287) (7401 . 7404)
    (7406 . 7409) (7413 . 7414) (7424 . 7467) (7531 . 7543)
    (7545 . 7551) (7552 . 7578) (7680 . 7935) (7936 . 7957) (7960 . 7965)
    (7968 . 8005) (8008 . 8013) (8016 . 8023) 8025 8027 8029
    (8031 . 8061) (8064 . 8116) (8118 . 8124) 8126 (8130 . 8132) (8134 . 8140)
    (8144 . 8147) (8150 . 8155) (8160 . 8172) (8178 . 8180)
    (8182 . 8188) 8304 (8308 . 8313) (8320 . 8329) 8450 8455 (8458 . 8467)
    8469 (8473 . 8477) 8484 8486 8488 (8490 . 8493) (8495 . 8505)
    (8508 . 8511) (8517 . 8521) 8526 (8528 . 8543) (8579 . 8580)
    8585 (9312 . 9371) (9450 . 9471) (10102 . 10131) (11264 . 11310)
    (11312 . 11358) (11360 . 11387) (11390 . 11391) (11392 . 11492)
    (11499 . 11502) (11506 . 11507) 11517 (11520 . 11557) 11559 11565
    (11568 . 11623) (11648 . 11670) (11680 . 11686) (11688 . 11694)
    (11696 . 11702) (11704 . 11710) (11712 . 11718) (11720 . 11726)
    (11728 . 11734) (11736 . 11742) 12294 12348 (12353 . 12438) 12447
    (12449 . 12538) 12543 (12549 . 12589) (12593 . 12686) (12690 . 12693)
    (12704 . 12730) (12784 . 12799) (12832 . 12841) (12872 . 12879)
    (12881 . 12895) (12928 . 12937) (12977 . 12991) (13312 . 19893)
    (19968 . 40908) (40960 . 40980) (40982 . 42124) (42192 . 42231)
    (42240 . 42507) (42512 . 42539) (42560 . 42606) (42624 . 42651)
    (42656 . 42725) (42786 . 42863) (42865 . 42887) (42891 . 42894)
    (42896 . 42925) (42928 . 42929) 42999 (43002 . 43007)
    (43008 . 43009) (43011 . 43013) (43015 . 43018) (43020 . 43042)
    (43056 . 43061) (43072 . 43123) (43138 . 43187) (43216 . 43225)
    (43250 . 43255) 43259 (43264 . 43301) (43312 . 43334) (43360 . 43388)
    (43396 . 43442) (43472 . 43481) (43488 . 43492) (43495 . 43518)
    (43520 . 43560) (43584 . 43586) (43588 . 43595) (43600 . 43609)
    (43616 . 43631) (43633 . 43638) 43642 (43646 . 43647)
    (43648 . 43695) 43697 (43701 . 43702) (43705 . 43709) 43712 43714
    (43739 . 43740) (43744 . 43754) 43762 (43777 . 43782) (43785 . 43790)
    (43793 . 43798) (43808 . 43814) (43816 . 43822) (43824 . 43866)
    (43876 . 43877) (43968 . 44002) (44016 . 44025) (44032 . 55203)
    (55216 . 55238) (55243 . 55291) (63744 . 64109) (64112 . 64217)
    (64256 . 64262) (64275 . 64279) 64285 (64287 . 64296)
    (64298 . 64310) (64312 . 64316) 64318 (64320 . 64321) (64323 . 64324)
    (64326 . 64335) (64336 . 64433) (64467 . 64829) (64848 . 64911)
    (64914 . 64967) (65008 . 65019) (65136 . 65140) (65142 . 65276)
    (65296 . 65305) (65313 . 65338) (65345 . 65370) (65382 . 65391)
    (65393 . 65437) (65440 . 65470) (65474 . 65479) (65482 . 65487)
    (65490 . 65495) (65498 . 65500) (65536 . 65547) (65549 . 65574)
    (65576 . 65594) (65596 . 65597) (65599 . 65613) (65616 . 65629)
    (65664 . 65786) (65799 . 65843) (65909 . 65912) (65930 . 65931)
    (66176 . 66204) (66208 . 66256) (66273 . 66299) (66304 . 66339)
    (66352 . 66368) (66370 . 66377) (66384 . 66421) (66432 . 66461)
    (66464 . 66499) (66504 . 66511) (66560 . 66639) (66640 . 66687)
    (66688 . 66717) (66720 . 66729) (66816 . 66855) (66864 . 66915)
    (67072 . 67382) (67392 . 67413) (67424 . 67431) (67584 . 67589)
    67592 (67594 . 67637) (67639 . 67640) 67644 67647 (67648 . 67669)
    (67672 . 67679) (67680 . 67702) (67705 . 67711) (67712 . 67742)
    (67751 . 67759) (67840 . 67867) (67872 . 67897) (67968 . 67999)
    (68000 . 68023) (68030 . 68031) 68096 (68112 . 68115)
    (68117 . 68119) (68121 . 68147) (68160 . 68167) (68192 . 68222)
    (68224 . 68255) (68288 . 68295) (68297 . 68324) (68331 . 68335)
    (68352 . 68405) (68416 . 68437) (68440 . 68447) (68448 . 68466)
    (68472 . 68479) (68480 . 68497) (68521 . 68527) (68608 . 68680)
    (69216 . 69246) (69635 . 69687) (69714 . 69743) (69763 . 69807)
    (69840 . 69864) (69872 . 69881) (69891 . 69926) (69942 . 69951)
    (69968 . 70002) 70006 (70019 . 70066) (70081 . 70084) (70096 . 70106)
    (70113 . 70132) (70144 . 70161) (70163 . 70187) (70320 . 70366)
    (70384 . 70393) (70405 . 70412) (70415 . 70416) (70419 . 70440)
    (70442 . 70448) (70450 . 70451) (70453 . 70457) 70461
    (70493 . 70497) (70784 . 70831) (70852 . 70853) 70855 (70864 . 70873)
    (71040 . 71086) (71168 . 71215) 71236 (71248 . 71257)
    (71296 . 71338) (71360 . 71369) (71840 . 71922) 71935 (72384 . 72440)
    (73728 . 74648) (77824 . 78894) (92160 . 92728) (92736 . 92766)
    (92768 . 92777) (92880 . 92909) (92928 . 92975) (93008 . 93017)
    (93019 . 93025) (93027 . 93047) (93053 . 93071) (93952 . 94020)
    94032 (110592 . 110593) (113664 . 113770) (113776 . 113788)
    (113792 . 113800) (113808 . 113817) (119648 . 119665) (119808 . 119892)
    (119894 . 119964) (119966 . 119967) 119970 (119973 . 119974)
    (119977 . 119980) (119982 . 119993) 119995 (119997 . 120003)
    (120005 . 120069) (120071 . 120074) (120077 . 120084)
    (120086 . 120092) (120094 . 120121) (120123 . 120126) (120128 . 120132)
    120134 (120138 . 120144) (120146 . 120485) (120488 . 120512)
    (120514 . 120538) (120540 . 120570) (120572 . 120596)
    (120598 . 120628) (120630 . 120654) (120656 . 120686) (120688 . 120712)
    (120714 . 120744) (120746 . 120770) (120772 . 120779)
    (120782 . 120831) (124928 . 125124) (125127 . 125135) (126464 . 126467)
    (126469 . 126495) (126497 . 126498) 126500 126503 (126505 . 126514)
    (126516 . 126519) 126521 126523 126530 126535 126537
    126539 (126541 . 126543) (126545 . 126546) 126548 126551 126553
    126555 126557 126559 (126561 . 126562) 126564 (126567 . 126570)
    (126572 . 126578) (126580 . 126583) (126585 . 126588) 126590 (126592 . 126601)
    (126603 . 126619) (126625 . 126627) (126629 . 126633)
    (126635 . 126651) (127232 . 127244) (131072 . 173782) (173824 . 177972)
    (177984 . 178205) (194560 . 195101)))

;;;###autoload
(defvar expresso-mode-syntax-table

  (let ((TABLE (make-syntax-table))
        )

    ;; « - » is punctuation (syntactically, an operator),
    ;; but « -- » is a comment starter:

    (modify-syntax-entry ?- ". 123" TABLE)

    ;; « \n » is a comment ender:

    (modify-syntax-entry ?\n ">" TABLE)

    ;; « " » is a string delimiter:

    (modify-syntax-entry ?\" "\"" TABLE)



    (modify-syntax-entry ?\  " " TABLE)
    (modify-syntax-entry ?\t " " TABLE)
    (modify-syntax-entry ?\n ">" TABLE)

    (modify-syntax-entry ?\" "\"" TABLE)
    (modify-syntax-entry ?\' "_"  TABLE)

    (modify-syntax-entry ?_  "_" TABLE)

    (modify-syntax-entry ?\( "()" TABLE)
    (modify-syntax-entry ?\) ")(" TABLE)
    (modify-syntax-entry ?\[ "(]" TABLE)
    (modify-syntax-entry ?\] ")[" TABLE)
    (modify-syntax-entry ?\{ "(}1nb" TABLE)
    (modify-syntax-entry ?\} "){4nb" TABLE)

    (modify-syntax-entry ?\` "$`" TABLE)

    (mapc (lambda (x)
            (modify-syntax-entry x "." TABLE))
          "!#$%&*+./:<=>?@^|~,;\\")

    ;; Expresso symbol characters are treated as punctuation because
    ;; they are not able to form identifiers with word constituent 'w'
    ;; class characters.
    (dolist (CHARCODES expresso--char-syntax-symbols)
      (modify-syntax-entry CHARCODES "." TABLE))
    ;; ... and for identifier characters
    (dolist (CHARCODES expresso--char-syntax-identifiers)
      (modify-syntax-entry CHARCODES "w" TABLE))

    TABLE)

  "Expresso Mode's `syntax-table-p'.")

##################################################

;;----------------------------------------------;;
;; Init ----------------------------------------;;
;;----------------------------------------------;;

(progn

  (setq helm-mode-fuzzy-match                 t)   ; 
  (setq helm-completion-in-region-fuzzy-match t)   ; 
  (setq helm-allow-mouse                      t)   ; 

  (setq helm-split-window-in-side-p           t)   ; open helm buffer inside current window, not occupy whole other window
  (setq helm-move-to-line-cycle-in-source     nil) ; move to end or beginning of source when reaching top or bottom of source
  (setq helm-scroll-amount                    8)   ; scroll 8 lines other window using M-<next>/M-<prior>
  (setq helm-ff-file-name-history-use-recentf t)   ; 
  (setq helm-echo-input-in-header-line        t)   ; 
  (setq helm-full-frame                       t)   ; 

  (custom-set-variables
   '(helm-register-max-offset 10000 t nil "Increase the Maximum Clipboard Size.")
   )

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  ())

;;----------------------------------------------;;
;; Load ----------------------------------------;;
;;----------------------------------------------;;

(progn
  (require 'helm-config)
  (helm-mode 1))

;;----------------------------------------------;;
;; Config --------------------------------------;;
;;----------------------------------------------;;

(define-key global-map [remap execute-extended-command] #'helm-M-x)
(define-key global-map [remap list-buffers]             #'helm-buffers-list)
(define-key global-map [remap find-file]                #'helm-find-files)
(define-key global-map [remap occur]                    #'helm-occur)

;;----------------------------------------------;;
;; Notes ---------------------------------------;;
;;----------------------------------------------;;

;; See:
;; - https://github.com/emacs-helm/helm

;;----------------------------------------------;;
(provide 'sboo-init-helm)

##################################################

(defun indent-according-to-mode ()

  "Indent line in proper way for current major mode.
Normally, this is done by calling the function specified by the
variable `indent-line-function'."

  (interactive)

  (save-restriction
    (widen)
    (funcall indent-line-function)))


;; `kill-region' or `kill-line'.

(defun sboo-kill-dwim ()

  "Do-What-I-Mean: `kill-region' or `kill-line'."

  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (list (line-beginning-position)
        (line-beginning-position 2)))))




(defun copy-region-as-kill-dwim ()
  "When called interactively with no active region, copy current line."
  (interactive)
  (let ((beg (if (makd-mark-active) (region-beginning) (point-at-bol)))
        (end (if (makd-mark-active) (region-end) (point-at-bol 2))))
    (copy-region-as-kill beg end)))

(defun kill-region-dwim ()
  "When called interactively with no active region, kill current line."
  (interactive)
  (let ((beg (if (makd-mark-active) (region-beginning) (point-at-bol)))
        (end (if (makd-mark-active) (region-end) (point-at-bol 2))))
    (kill-region beg end)))




##################################################


;;; sboo-helm.el --- SBoo's startup file for helm. -*- lexical-binding: t -*- 
;;; Code:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun sboo-init-helm! ()

  "Initialize `helm' variables.

Fast & Safe (only `setq's or `defvar's).
"
  (interactive)

  (progn

     (setq helm-mode-fuzzy-match                 t)
     (setq helm-completion-in-region-fuzzy-match t)

     ;; ^ fuzzy-matching.

     ;; helm-boring-buffer-regexp-list '()
     ;;
     ;; ;; ^
     ;; ;; by default, `helm-boring-buffer-regexp-list' is:
     ;; ;;     ("\\` " "\\`\\*helm" "\\`\\*Echo Area" "\\`\\*Minibuf")
     ;; ;;

     (setq helm-allow-mouse t)

     ;; ^ the mouse is gratuitously disabled by default.
     ;; this enables, for example, clicking on a helm candidate to activate it,
     ;; rather than navigating it with several arrow and/or character keypresses.
     ;;

     ()))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun sboo-config-helm! ()

  "Require `helm' and configure `helm-mode'.

Idempotent (invoking it twice is the same as calling once).

Safe (doesn't throw an error when the package can't be `load'ed).
"
  (interactive)

  (when (require 'helm-config nil t)
    (helm-mode 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(progn
  (sboo-init-helm!)
  (add-hook 'emacs-startup-hook #'sboo-config-helm!)
  ())

;; ^ 
;; 
;; "`emacs-startup-hook' runs later than the `after-init-hook'."
;;
;; See:
;; - https://www.gnu.org/software/emacs/manual/html_node/elisp/Hooks.html#Hooks
;; - https://emacs.stackexchange.com/questions/14551/whats-the-difference-between-after-init-hook-and-emacs-startup-hook
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Notes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; "Helm is a framework for incremental narrowing and selecting."

;; See:
;;
;; - https://emacs-helm.github.io/helm/
;; - https://github.com/emacs-helm/helm/wiki
;; - https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/init-helm.el
;; - 
;;

;; [Problem] "helm-interpret-value: Wrong number of arguments: (1 . 1), 0"
;;
;; [Solution] ?
;; 
;; a cloned `./helm/emacs-helm.sh' does work (i.e. `helm-M-x', `helm-find-file', etc).
;; 

;; `helm-boring-buffer-regexp-list'
;; 
;; by default, `helm-boring-buffer-regexp-list' is:
;;
;;     ("\\` " "\\`\\*helm" "\\`\\*Echo Area" "\\`\\*Minibuf")
;;

;; e.g.
;;
;; (use-package helm
;;   :defer t
;;   :bind (:map helm-map
;;               ("<tab>" . helm-execute-persistent-action)
;;               ("C-i"   . helm-execute-persistent-action)
;;               ("C-z"   . helm-select-action)
;;               ("A-v"   . helm-previous-page))
;;   :config
;;   (helm-autoresize-mode 1))
;;   ;; from jwiegley's configuration.

;; ;;; "Extended Config" from http://tuhdo.github.io/helm-intro.html

;; (require 'helm)
;; (require 'helm-config)

;; ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
;; ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
;; ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.

;; (global-set-key (kbd "C-c h") 'helm-command-prefix)
;; (global-unset-key (kbd "C-x c"))

;; (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
;; (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
;; (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

;; (when (executable-find "curl")
;;   (setq helm-google-suggest-use-curl-p t))

;; (setq 
;;       helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
;;       helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
;;       helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
;;       helm-ff-file-name-history-use-recentf t
;;       helm-echo-input-in-header-line t)

;; (setq helm-autoresize-max-height 0)
;; (setq helm-autoresize-min-height 20)
;; (helm-autoresize-mode 1)

;; (helm-mode 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(provide 'sboo-helm)

##################################################



(progn

  (setq helm-mode-fuzzy-match                 t)   ; 
  (setq helm-completion-in-region-fuzzy-match t)   ; 
  (setq helm-allow-mouse                      t)   ; 

  (setq helm-split-window-in-side-p           t)   ; open helm buffer inside current window, not occupy whole other window
  (setq helm-move-to-line-cycle-in-source     nil) ; move to end or beginning of source when reaching top or bottom of source
  (setq helm-scroll-amount                    8)   ; scroll 8 lines other window using M-<next>/M-<prior>
  (setq helm-ff-file-name-history-use-recentf t)   ; 
  (setq helm-echo-input-in-header-line        t)   ; 
  (setq helm-full-frame                       t)   ; 

  (custom-set-variables
   '(helm-register-max-offset 10000 t nil "Increase the Maximum Clipboard Size.")
   )

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  ())







https://github.com/jaypei/emacs-neotree




wget https://raw.githubusercontent.com/tsdh/highlight-parentheses.el/master/highlight-parentheses.e


wget https://raw.githubusercontent.com/Wilfred/helpful/master/helpful.el









wget https://raw.githubusercontent.com/ankurdave/color-identifiers-mode/master/color-identifiers-mode.el

wget https://camo.githubusercontent.com/c1eecef199dd64490ad586bfe71364ddcba19a3a/68747470733a2f2f7261772e6769746875622e636f6d2f616e6b7572646176652f636f6c6f722d6964656e746966696572732d6d6f64652f67682d70616765732f64656d6f2d7374617469632e706e67

md img
mv c1eecef199dd64490ad586bfe71364ddcba19a3a/68747470733a2f2f7261772e6769746875622e636f6d2f616e6b7572646176652f636f6c6f722d6964656e746966696572732d6d6f64652f67682d70616765732f64656d6f2d7374617469632e706e67 img/color-identifiers-mode.jpg









(progn
  (define-prefix-command 'sboo-paths-keymap)

  ;; ^ aliases and /or keyboard shortcuts for frequently-visited files and/or directories .

;;(define-key sboo-paths-keymap (kbd "a") "")
;;(define-key sboo-paths-keymap (kbd "b") "")
;;(define-key sboo-paths-keymap (kbd "c") "")
;;(define-key sboo-paths-keymap (kbd "d") "")
  (define-key sboo-paths-keymap (kbd "e") "~/.emacs.d" )
;;(define-key sboo-paths-keymap (kbd "f") "")
;;(define-key sboo-paths-keymap (kbd "g") "")
;;(define-key sboo-paths-keymap (kbd "h") "")
;;(define-key sboo-paths-keymap (kbd "i") "")
;;(define-key sboo-paths-keymap (kbd "j") "")
;;(define-key sboo-paths-keymap (kbd "k") "")
;;(define-key sboo-paths-keymap (kbd "l") "")
;;(define-key sboo-paths-keymap (kbd "m") "")
;;(define-key sboo-paths-keymap (kbd "n") "")
;;(define-key sboo-paths-keymap (kbd "o") "")
;;(define-key sboo-paths-keymap (kbd "p") "")
;;(define-key sboo-paths-keymap (kbd "q") "")
;;(define-key sboo-paths-keymap (kbd "r") "")
;;(define-key sboo-paths-keymap (kbd "s") "")
;;(define-key sboo-paths-keymap (kbd "t") "")
;;(define-key sboo-paths-keymap (kbd "u") "")
;;(define-key sboo-paths-keymap (kbd "v") "")
;;(define-key sboo-paths-keymap (kbd "w") "")
;;(define-key sboo-paths-keymap (kbd "x") "")
;;(define-key sboo-paths-keymap (kbd "y") "")
;;(define-key sboo-paths-keymap (kbd "z") "")

  #'sboo-paths-keymap)














# -*- mode: snippet -*-
#
# key         : url
# name        : [sboo] a « URL `...' » hyperlink.
#
# type        : snippet
# condition   : t
# expand-env  : ((yas-wrap-around-region t) (yas-indent-line 'auto))
#
# contributor : Spiros Boosalis <samboosalis@gmail.com> 
# commentary  : TODO « condition » upon being within a Comment or String.
#
# --
URL \``yas-selected-text`'































;;----------------------------------------------;;
;; Completion

(use-package dabbrev

  :diminish (abbrev-mode " A")

  :custom

  (abbrev-file-name (sboo-xdg-config "dabbrev/abbrev_defs.el") "« XDG-BaseDirs » conformant.")

  :config

  (add-hook 'text-mode-hook #'abbrev-mode)

  (when (file-exists-p abbrev-file-name)
    (quietly-read-abbrev-file))

  ())

;; ^ "`dabbrev'" abbreviates "Dynamic ABBREViation".

;; ^ Links:
;;
;;   • URL `https://www.gnu.org/software/emacs/manual/html_node/elisp/Abbrev-Files.html'
;;   • URL `http://ergoemacs.org/emacs/emacs_abbrev_mode_tutorial.html'
;;   • URL `https://www.emacswiki.org/emacs/AbbrevMode'
;;













# -*- mode: snippet -*-
#
# key         : dockbd
# name        : [sboo] Docstring: a command's live keybinding(s) (e.g. « \\[find-file] »)
#
# type        : snippet
# condition   : t
# expand-env  : ((yas-wrap-around-region t) (yas-indent-line 'auto))
#
# contributor : Spiros Boosalis <samboosalis@gmail.com> 
# commentary  : TODO « condition » upon being within a Comment or String.
# --
\\\\[`
(let* ((CHOICES ())
       )
  (cl-some (lambda (fn) (funcall fn "Command: " CHOICES)) yas-prompt-functions))
`$0]





# -*- mode: snippet -*-
#
# key         : dockbd
# name        : [sboo] Docstring: a command's live keybinding(s) (e.g. « \\[find-file] »)
#
# type        : snippet
# condition   : t
# expand-env  : ((yas-wrap-around-region t) (yas-indent-line 'auto))
#
# contributor : Spiros Boosalis <samboosalis@gmail.com> 
# commentary  : TODO « condition » upon being within a Comment or String.
# --
\\\\[`

(let* ((CHOICES   obarray)
       (PREDICATE #'commandp)
       (INITIAL   nil)
       (PROMPT    "Command: ")
       )
  (completing-read PROMPT CHOICES PREDICATE nil INITIAL))

`$0]



























(use-package rainbow-delimiters

  :commands (rainbow-delimiters-mode)

  :custom-face

  (rainbow-delimiters-max-face-count 6 "fewer faces, higher-contrast.")

  ;;TODO:

  ;; (rainbow-delimiters-depth-1-face )
  ;; (rainbow-delimiters-depth-2-face )
  ;; (rainbow-delimiters-depth-3-face )
  ;; (rainbow-delimiters-depth-4-face )
  ;; (rainbow-delimiters-depth-5-face )
  ;; (rainbow-delimiters-depth-6-face )

  ;; (rainbow-delimiters-unmatched-face )
  ;; (rainbow-delimiters-mismatched-face )

  :config

  (let* ((LISP-HOOKS
          (if (require 'sboo-lisp nil :no-error)
              sboo-lisp-hooks
            '(emacs-lisp-mode-hook)))
         )

    (dolist (HOOK LISP-HOOKS)
      (add-hook HOOK #'rainbow-delimiters-mode)))

  ())
























































































;;----------------------------------------------;;
;; `upcase-word'
;; `upcase-region'

;; (sboo-defmarco-region-dwim upcase-dwim upcase-region upcase-word)

;;----------------------------------------------;;

;; `downcase-word'
;; `downcase-region'

;;----------------------------------------------;;

;; `capitalize-word'
;; `capitalize-region'

;;----------------------------------------------;;



























##################################################


;;----------------------------------------------;;

(when (require 'sboo-yasnippets nil :no-error)

  (use-package yasnippet-snippets

    ;;------------------------;;

    :config

    ()))

;; ^ Links:
;;
;;   • URL `https://github.com/AndreaCrotti/yasnippet-snippets'
;;   • URL `http://andreacrotti.github.io/yasnippet-snippets/snippets.html'
;;













;;(global-set-key (kbd "<f5>") nil)          ;; « xfce4 » sends « C-c » on « F5 », i.e. Copy / User-Keymap.
;;(global-set-key (kbd "<f6>") nil)          ;; « xfce4 » sends « C-x » on « F6 », i.e. Cut / Extra-Keymap.
(global-set-key (kbd "<f7>") #'list-buffers)
;;(global-set-key (kbd "<f8>") nil)          ;; « xfce4 » sends « C-v » on « F8 », i.e. Paste.























(add-hook 'after-init-hook
          (lambda ()
            (with-current-buffer sboo-init-file
              (sboo-set-font-to-iosevka))))



















;; ;;
;; ;;  bm
;; ;;  bookmark+ (bmkp)
;; ;;  Quickly save and restore point using registers

;; ;;; bm
;; ;; https://github.com/joodland/bm
;; (use-package bm

;;   :config
;;   (progn
;;     (setq-default bm-buffer-persistence t) ; buffer persistence on by default

;;     (when (display-graphic-p) ; Add fringe only if display is graphic (GUI)
;;       (define-fringe-bitmap 'bm-marker-left [#xF8    ; ▮ ▮ ▮ ▮ ▮ 0 0 0
;;                                              #xFC    ; ▮ ▮ ▮ ▮ ▮ ▮ 0 0
;;                                              #xFE    ; ▮ ▮ ▮ ▮ ▮ ▮ ▮ 0
;;                                              #x0F    ; 0 0 0 0 ▮ ▮ ▮ ▮
;;                                              #x0F    ; 0 0 0 0 ▮ ▮ ▮ ▮
;;                                              #xFE    ; ▮ ▮ ▮ ▮ ▮ ▮ ▮ 0
;;                                              #xFC    ; ▮ ▮ ▮ ▮ ▮ ▮ 0 0
;;                                              #xF8])) ; ▮ ▮ ▮ ▮ ▮ 0 0 0
;;     ()))

















(when (let* ((KEYMAP (current-global-map))) (ignore-errors (kbd "<f1>") KEYMAP))
  (global-set-key (kbd "<f1>") #'dabbrev-completion))     ; « F1 » is the “Complete Key”. Overriden by « (use-package ??? ...) ».



(when (not (eq #'dabbrev-completion (global-key-binding (kbd "<f1>"))))
  (global-set-key (kbd "<f1>") #'dabbrev-completion))     ; « F1 » is the “Complete Key”. Overriden by « (use-package ??? ...) ».

(when (not (eq #'helm-swoop (global-key-binding (kbd "<f2>"))))
  (global-set-key (kbd "<f2>") #'isearch-forward-regexp)) ; « F2 » is the “Search Key”. Overriden by « (use-package helm-swoop ...) ».
















;;----------------------------------------------;;
;; Register ------------------------------------;;
;;----------------------------------------------;;

(let* (((APPEND nil)))                  ; prepend (to the start).
  (add-to-list 'load-path sboo-root-directory APPEND))

(let* (((APPEND t)))                    ; append (to the end).
  (add-to-list 'load-path sboo-lisp-directory APPEND))




(progn

  (add-to-list 'load-path sboo-root-directory nil)

  ;; ^ prepend (to the start of `load-path'):
  ;; 
  ;;   • `sboo-root-directory' holds « sboo-*.el » `featurep's.
  ;; 

  (add-to-list 'load-path sboo-lisp-directory t)

  ;; ^ append (to the end of `load-path'):
  ;; 
  ;;   • `sboo-lisp-directory' holds Vendored Packages,
  ;;     which have lower priority than Installed Packages
  ;;     (whether installed via program `nix' or via `package.el'.)
  ;;

  load-path)













(progn

  ;;--------------------------;;

  (defun sboo-shell-pop-launch ()
    "Launch `ansi-term' for function `shell-pop'."
    (ansi-term shell-pop-term-shell))

  ;;--------------------------;;

  (use-package shell-pop

    :commands (shell-pop)

    :bind (("s-x s" . shell-pop)
           )

    :custom

    (shell-pop-term-shell "/bin/bash"                                              "Bash")
    (shell-pop-shell-type (list "ansi-term" "*ansi-term*" #'sboo-shell-pop-launch) "use `ansi-term' (not `shell').")

    :config

    (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)

    ()))

;; ^ Links:
;;
;;   • URL `http://pragmaticemacs.com/emacs/pop-up-a-quick-shell-with-shell-pop/'
;;   • URL `https://github.com/kyagi/shell-pop-el'
;;
























(progn
  (define-prefix-command 'sboo-select-keymap)

  (define-key sboo-select-keymap (kbd "a") #'mark-beginning-of-buffer)
  (define-key sboo-select-keymap (kbd "b") #'mark-whole-buffer)
;;(define-key sboo-select-keymap (kbd "c") #'mark-)
  (define-key sboo-select-keymap (kbd "d") #'mark-defun)
  (define-key sboo-select-keymap (kbd "e") #'mark-end-of-buffer)
;;(define-key sboo-select-keymap (kbd "f") #'mark-)
;;(define-key sboo-select-keymap (kbd "g") #'mark-)
;;(define-key sboo-select-keymap (kbd "h") #'mark-)
;;(define-key sboo-select-keymap (kbd "i") #'mark-)
;;(define-key sboo-select-keymap (kbd "j") #'mark-)
;;(define-key sboo-select-keymap (kbd "k") #'mark-)
;;(define-key sboo-select-keymap (kbd "l") #'mark-)
;;(define-key sboo-select-keymap (kbd "m") #'mark-)
;;(define-key sboo-select-keymap (kbd "n") #'mark-)
;;(define-key sboo-select-keymap (kbd "o") #'mark-)
  (define-key sboo-select-keymap (kbd "p") #'mark-paragraph)
;;(define-key sboo-select-keymap (kbd "q") #'mark-)
;;(define-key sboo-select-keymap (kbd "r") #'mark-)
;;(define-key sboo-select-keymap (kbd "s") #'mark-)
;;(define-key sboo-select-keymap (kbd "t") #'mark-)
;;(define-key sboo-select-keymap (kbd "u") #'mark-)
;;(define-key sboo-select-keymap (kbd "v") #'mark-)
  (define-key sboo-select-keymap (kbd "w") #'mark-word)
  (define-key sboo-select-keymap (kbd "x") #'mark-sexp)
;;(define-key sboo-select-keymap (kbd "y") #'mark-)
;;(define-key sboo-select-keymap (kbd "z") #'mark-)

  #'sboo-select-keymap)








;;==============================================;;

(defun sboo-next-page-break ()

  "Move to the next Page-Break (i.e. « ^L »)."

  ())

;;----------------------------------------------;;

(defun sboo-prior-page-break ()

  "Move to the prior Page-Break (i.e. « ^L »)."

  ())












(progn

  ;;--------------------------;;

  (defun sboo-goto-last-change ()
    "Invert `goto-last-change'."        ;TODO
    (interactive "P")
    (goto-last-change -1))

  ;;--------------------------;;

  (use-package goto-last-change

  :commands (goto-last-change)

  :bind (("<C-left>"  . goto-last-change)
        ;; ("<C-right>" . sboo-goto-last-change)
         )

  :config

  ()))

;; ^ Links:
;;
;;   • URL `https://github.com/camdez/goto-last-change.el'
;;



















==============================================

https://github.com/danlamanna/.emacs.d/blob/master/init.el

(use-package uniquify
  :config (custom-set-variables
           '(uniquify-buffer-name-style 'reverse)
           '(uniquify-separator " - ")
           '(uniquify-after-kill-buffer-p t)
           '(uniquify-ignore-buffers-re "^\\*")))


(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq buffer-file-coding-system 'utf-8)

(put 'narrow-to-region 'disabled nil)





















  (wrap-region-add-wrappers

   `(

     ("`" "`" nil (markdown-mode gfm-mode))

     ;; ^ « <code> » syntax (e.g. « `pandoc` »).

     ("%" "%" nil (bat-mode))

     ;; ^ Environment-Variable syntax (e.g. « %APPDATA% »).

     ("{-" "-}"    ";" (haskell-mode))

     ("/* " " */"  ";" (nix-mode javascript-mode css-mode java-mode))

     ("<!--" "-->" ";" ,(or (bound-and-true-p sboo-html-modes-list) '(html-mode)))

     ("#|" "|#"    ";" (scheme-mode))

     ;; ^ Mode-Specific, Multi-Line Comments:
     ;;
     ;;   • « ; » (i.e. the semicolon character)
     ;;     is our universal trigger-key for commenting a region;
     ;;     c.f. « M-; » runs `comment-dwim' across langauges.
     ;;

     ))




     ("`" "'" "`" (emacs-lisp-mode))

     ;; ^ Syntax for hyperlinks, in Elisp (docstrings).
     ;;   « `...' » is the ASCII-version of  « ‘...’ » .




       ("_" "_" nil ,(append MARKDOWN-MODES '(haskell-mode haddock-mode)))

       ;; ^ Syntax for emphasis, in Markdown and Haddocks.
       ;;   i.e. « _ » for « <em> », and « __ » for « <strong> ».

       ("_" "_" nil ,(append MARKDOWN-MODES '(haskell-mode haddock-mode)))

       ;; ^ Syntax for emphasis, in Markdown and Haddocks.
       ;;   i.e. « _ » for « <em> », and « __ » for « <strong> ».











print-builtin-symbols:

	$(Emacs) --eval

.PHONY: print-builtin-symbols

















🌣 🌞 ⛅ 🌤 🌥 ⛱
⛆ 🌢 ☂ ☔ 🌂 🌦 🌧 🌨 🌩 ⛈
❄ ❅ ❆ 🎐 ☃ ⛄ ⛇
🌪 🌀 ☇ ☈ ☁ 🌫 🌁 🌈 🌬

























(use-package grep

  :commands (grep grep-find)

  ;;--------------------------;;

  :hook (grep-mode . sboo-grep-config)

  ;;--------------------------;;

  :config

  (defun sboo-grep-config ()

    "Hook for `grep-mode'."

    (toggle-truncate-lines +1))

  ;;--------------------------;;

  (dolist (CONS '(("hs" . "*.hs")
                  ("md" . "*.md")
                  ))
    (add-to-list 'grep-files-aliases CONS))

  ;;--------------------------;;

  (dolist (DIRECTORY '("tmp" "old" "stdout"
                       "dist" "dist-newstyle" "dist-dante" ".stack-work"
                       "elpa" ".cask"
                       "node_modules" ".bundle"
                       ))
    (add-to-list 'grep-find-ignored-directories DIRECTORY))

  ;;--------------------------;;

  ())





(use-package grep

  :commands (grep grep-find)

  ;;--------------------------;;

  :hook (grep-mode . sboo-grep-config)

  ;;--------------------------;;

  :custom

  (grep-files-aliases (append '(("hs" . "*.hs")
                                ("md" . "*.md")
                                )
                              grep-files-aliases))

  (grep-find-ignored-directories (append '("tmp" "old" "stdout"
                                          "dist" "dist-newstyle" "dist-dante" ".stack-work"
                                          "elpa" ".cask"
                                          "node_modules" ".bundle"
                                          )
                                         grep-find-ignored-directories))

  ;;--------------------------;;

  :config

  (defun sboo-grep-config ()

    "Hook for `grep-mode'."

    (toggle-truncate-lines +1))

  ;;--------------------------;;

  ())















;;----------------------------------------------;;
;;; Settings -----------------------------------;;
;;----------------------------------------------;;

;; Keyboard Settings...

(progn
  ;; Insert Unicode Characters...

  (define-key key-translation-map (kbd "H-o") (kbd "•")) ; BULLET
  (define-key key-translation-map (kbd "H-4") (kbd "◇")) ; WHITE DIAMOND

  (define-key key-translation-map (kbd "H-1") (kbd "①")) ; 
  (define-key key-translation-map (kbd "H-2") (kbd "②")) ;
  (define-key key-translation-map (kbd "H-3") (kbd "③")) ; 
  (define-key key-translation-map (kbd "H-4") (kbd "")) ; 
  (define-key key-translation-map (kbd "H-5") (kbd "")) ;
  (define-key key-translation-map (kbd "H-6") (kbd "")) ; 
  (define-key key-translation-map (kbd "H-7") (kbd "")) ; 
  (define-key key-translation-map (kbd "H-8") (kbd "")) ;
  (define-key key-translation-map (kbd "H-9") (kbd "")) ; 
  (define-key key-translation-map (kbd "H-10") (kbd "")) ; 

  ())

;; Hyper and Super:

;; Modifier Keys:
;;
;; • ❖ Window key (Windows keyboard)
;; • ▤ Menu key (Windows keyboard)
;; • ⌥ Option key (Apple keyboard)
;; • ⌘ Command key (Apple keyboard)
;;
;; 

;; ^ Links:
;;
;;   • URL `http://ergoemacs.org/emacs/emacs_hyper_super_keys.html'
;;   • URL `'
;;
















(defalias 'yes-or-no-p #'y-or-n-p)








==============================================


$ ./install.sh 
+ DATA=/home/sboo/.local/share/icons-in-terminal/
+ mkdir -p /home/sboo/.fonts
+ cp ./build/icons-in-terminal.ttf /home/sboo/.fonts/
+ mkdir -p /home/sboo/.config/fontconfig/conf.d
+ ./scripts/generate_fontconfig.sh
Fontconfig error: "/home/sboo/.config/fontconfig/conf.d/30-icons.conf", line 8: no element found
+ fc-cache -fvr --really-force /home/sboo/.fonts
/home/sboo/.fonts: caching, new cache contents: 1 fonts, 6 dirs
/home/sboo/.fonts/all-the-icons: caching, new cache contents: 0 fonts, 1 dirs
/home/sboo/.fonts/all-the-icons/ttf: caching, new cache contents: 0 fonts, 0 dirs
/home/sboo/.fonts/dejavu: caching, new cache contents: 0 fonts, 2 dirs
/home/sboo/.fonts/dejavu/fontconfig: caching, new cache contents: 0 fonts, 0 dirs
/home/sboo/.fonts/dejavu/ttf: caching, new cache contents: 22 fonts, 0 dirs
/home/sboo/.fonts/iosevka: caching, new cache contents: 0 fonts, 2 dirs
/home/sboo/.fonts/iosevka/ttf: caching, new cache contents: 27 fonts, 0 dirs
/home/sboo/.fonts/iosevka/woff2: caching, new cache contents: 0 fonts, 0 dirs
/home/sboo/.fonts/noto: caching, new cache contents: 0 fonts, 2 dirs
/home/sboo/.fonts/noto/otf: caching, new cache contents: 64 fonts, 0 dirs
/home/sboo/.fonts/noto/ttf: caching, new cache contents: 1541 fonts, 0 dirs
/home/sboo/.fonts/quivira: caching, new cache contents: 0 fonts, 1 dirs
/home/sboo/.fonts/quivira/otf: caching, new cache contents: 1 fonts, 0 dirs
/home/sboo/.fonts/symbola: caching, new cache contents: 0 fonts, 1 dirs
/home/sboo/.fonts/symbola/ttf: caching, new cache contents: 2 fonts, 0 dirs
/var/cache/fontconfig: not cleaning unwritable cache directory
/home/sboo/.cache/fontconfig: cleaning cache directory
/home/sboo/.fontconfig: not cleaning non-existent cache directory
fc-cache: succeeded
+ mkdir -p /home/sboo/.local/share/icons-in-terminal/
+ cp ./build/icons-in-terminal.el ./build/icons-in-terminal.h ./build/icons-in-terminal.ttf ./build/icons.fish ./build/icons_bash.sh ./build/icons_bash_export.sh ./build/icons_bash_without_codepoint.sh ./build/mapping.txt /home/sboo/.local/share/icons-in-terminal/
+ set +xe

Recommended additional step:
Edit ~/.config/fontconfig/conf.d/30-icons.conf
Check that the font(s) you are using in your terminal(s) is listed and remove all the others lines

Font successfully installed. Now start a new terminal and run print_icons.sh :)



----------------------------------------------

<?xml version="1.0"?>
<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
  <!-- You are supposed to remove all the lines but the one(s) where the font is used in your terminal -->
  <!-- Only monospaced fonts have been listed here -->
  <!-- If your font isn't in the list, uncomment the next line and write its name -->
  <!-- <alias><family>YOUR_TERMINAL_FONT</family><default><family>icons-in-terminal</family></default></alias> -->
  <alias><family>Courier 10 Pitch</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>DejaVu Sans Mono</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>FreeMono</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Liberation Mono</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Nimbus Mono L</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Noto Color Emoji</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Noto Emoji</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Noto Mono</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Tlwg Mono</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Tlwg Typo</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Ubuntu Mono</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>cursor.pcf</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>deccurs.pcf</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>decsess.pcf</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>micro.pcf</family><prefer><family>icons-in-terminal</family></prefer></alias>
  <alias><family>Monospace</family><default><family>icons-in-terminal</family></default></alias>
</fontconfig>

----------------------------------------------

$ ./print_icons.sh

powerline-extras (38 glyphs):
                                                                          

octicons (172 glyphs):
                                                                                                                                                                                                                                                                                                                                                      

fontawesome (679 glyphs):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

material (933 glyphs):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

fileicons (456 glyphs):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

weather (228 glyphs):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

linux (28 glyphs):
                                                      

myicons (18 glyphs):
                                  

devicons (198 glyphs):
                                                                                                                                                                                                                                                                                                                                                                                                          

pomicons (11 glyphs):
                    

linea-arrows (136 glyphs):
                                                                                                                                                                                                                                                                              

linea-basic (135 glyphs):
                                                                                                                                                                                                                                                                            

linea-basic-elaboration (145 glyphs):
                                                                                                                                                                                                                                                                                                

linea-ecommerce (85 glyphs):
                                                                                                                                                                        

linea-music (30 glyphs):
                                                          

linea-software (100 glyphs):
                                                                                                                                                                                                      

linea-weather (85 glyphs):
                                                                                                                                                                        

mfizz (137 glyphs):
                                                                                                                                                                                                                                                                                

firacode (116 glyphs):
                                                                                                                                                                                                                                      

Total: 3730 glyphes

==============================================

;;==============================================;;

(defun sboo-swap-parentheses-and-square-brackets ()
  
  "Swap « [ ] » with « (  ) ».

Calls:

• `keyboard-translate'.

Links:

• URL `https://www.cliki.net/Editing+Lisp+Code+with+Emacs'."

  (interactive)
  
  (keyboard-translate ?\( ?\[)
  (keyboard-translate ?\[ ?\()

  (keyboard-translate ?\) ?\])
  (keyboard-translate ?\] ?\)))

;;----------------------------------------------;;

(defun sboo-swap-semicolon-and-colon ()
  
  "Swap « ; » with « : ».

Calls:

• `keyboard-translate'.

Links:

• URL `https://www.cliki.net/Editing+Lisp+Code+with+Emacs'."

  (interactive)

  (keyboard-translate ?\: ?\;)
  (keyboard-translate ?\; ?\:))

;;----------------------------------------------;;

(defun sboo-swap-double-quote-with-single-quote ()
  
  "Swap « ' » with « \" ».

Calls:

• `keyboard-translate'.

Links:

• URL `https://www.cliki.net/Editing+Lisp+Code+with+Emacs'."

  (interactive)

  (keyboard-translate ?\" ?\')
  (keyboard-translate ?\' ?\"))

;;----------------------------------------------

;; (unless t
;;   ;; ^ whether these keyboard translations have already been configured globally
;;   ;;   (e.g. via « xmodmap »)
;;   (sboo-swap-parentheses-and-square-brackets)
;;   (sboo-swap-semicolon-and-colon)
;;   (sboo-swap-double-quote-with-single-quote)
;;   ())

==============================================







      (ispell-personal-dictionary (sboo-xdg-config "sboo.txt" :subdir "ispell")
                                  "XDG-conformant (defaults to « ~/.ispell_<DICTNAME> »).")







;;----------------------------------------------;;

(defvar sboo-spelling-personal-dictionary

  (if sboo-spelling-aspell-p
      (sboo-xdg-config "en.pws" :subdir "aspell")
    (sboo-xdg-config "sboo.txt" :subdir "ispell"))

  "Personal dictionary for spell-checkers.")














(when (require 'sboo-auto-mode nil :no-error)

  ;;------------------------;;

  (add-to-list 'auto-mode-alist (cons (rx bos "TODO" eos) #'text-mode))

  (sboo-add-auto-mode-basename "LICENSE" #'text-mode)
  (sboo-add-auto-mode-basename "NOTES"   #'text-mode)

  (sboo-add-auto-mode-basename ".gitignore"     #'conf-mode)
  (sboo-add-auto-mode-basename ".gitattributes" #'conf-mode)

  (sboo-add-auto-mode-basename "terminalrc" #'conf-mode)
  ;; ^ for the « xfce4-terminal » program.

  (sboo-add-auto-mode-basename ".xbindkeysrc" #'conf-mode)
;;(sboo-add-auto-mode-basename "xbindkeysrc.scm" #'xbindkeys-scheme-mode)
  ;; ^ for the « xbindkeys » program.

  ;;------------------------;;

  (add-to-list 'auto-mode-alist (cons "\\.xpm\\'" #'c-mode))

  (sboo-add-auto-mode-file-extension "service"    #'conf-mode) ; e.g. « /etc/services »
  (sboo-add-auto-mode-file-extension "interfaces" #'conf-mode) ; e.g. « /etc/network/interfaces »

  (sboo-add-auto-mode-file-extension "rc" #'conf-mode)

  ;; ^ Most `.rc' files (including « ~/.config/xfce4/panel/*-*.rc »),
  ;; have the `INI' format, which `conf-mode' supports.

  (sboo-add-auto-mode-file-extension "knsrc" #'conf-mode)

  ;; ^ `.knsrc' files (for KDE)
  ;; have the `INI' format, which `conf-mode' supports.

  ;;TODO any file that ends in `rc`, should we default to 'conf-mode or to 'sh-mode?
  ;;;(add-to-list 'auto-mode-alist ("rc\\'" . #'conf-mode))
  ;;;(add-to-list 'auto-mode-alist ("rc\\'" . #'sh-mode))

  (sboo-add-auto-mode-file-extension "xml" #'sgml-mode)

  ;; ^ `nxml-mode' vs `sgml-mode'.?

  ;;---------------------------;;

  ())

;; ^ NOTES:
;;
;;  • `auto-mode-alist' maps filepaths to `major-mode's.
;;







    (sboo-add-auto-mode-file-extension "rc"         #'conf-mode)

    ;; ^ Most `.rc' files are in the INI Format (which `conf-mode' supports).
    ;;   e.g. all « ~/.config/xfce4/panel/*-*.rc » Xfce Config-Files.

    (sboo-add-auto-mode-file-extension "knsrc"      #'conf-mode)

    ;; ^ `.knsrc' files (KDE Config-Files) are `.rc' files (and thus, in the INI Format).

==============================================

#!/usr/bin/emacs --script

;;; Commentary:

;; .
;; 
;; 

;;; Code:

;;----------------------------------------------;;
;; Imports -------------------------------------;;
;;----------------------------------------------;;

;; builtins:

(eval-when-compile
  (require 'cl-lib))

;;----------------------------------------------;;

(progn
  (require 'seq))

;;----------------------------------------------;;
;; Variables -----------------------------------;;
;;----------------------------------------------;;

(defvar sboo-builtin-features-list

  (seq-map #'car package--builtins)

  "")

;;----------------------------------------------;;

(defvar sboo-builtin-symbols-list nil
  "")

(defun sboo-register-builtin-symbols (symbol)
  (push symbol sboo-builtin-symbols-list))

(mapatoms #'sboo-builtin-symbols-list)

(dolist (FEATURE sboo-builtin-features-list)
  (require FEATURE))

;;----------------------------------------------;;

(prin1 sboo-builtin-symbols-list)

;;----------------------------------------------;;

;;----------------------------------------------;;
;; Notes ---------------------------------------;;
;;----------------------------------------------;;

;; ‘package--builtins’:
;;
;; (progn (require 'package) (describe-variable 'package--builtins))
;;

;;----------------------------------------------;;
;; EOF -----------------------------------------;;
;;----------------------------------------------;;

(provide 'print-builtin-symbols)

;;; print-builtin-symbols.el ends here

==============================================

;;----------------------------------------------;;

(cl-defmacro define-graceful-boolean-command 

  ( NAME
    &key internal external doc
  )

  `(defun ,NAME (PrefixArgument)
     
     ,doc
     
     (interactive "P")
     
     (let ((*command* (function ,external)))

        (if (commandp *command*)

          (call-interactively *command*)

          (call-interactively (function ,internal) PrefixArgument)))))


;; ^ `defalias' for commands with graceful degradation.
;;
;; Wraps `defun' and `call-interactively'.
;;
;; See:
;; 
;; - https://stackoverflow.com/questions/37531124/emacs-how-to-use-call-interactively-with-parameter
;; - 
;; 

;; ^ NOTES
;;
;; • `use-region-p':
;;
;;   Return `t' if ① the region is active and ② it is appropriate to act on it.


==============================================

(use-package term

  :bind (:map term-mode-map

              ("<C-v>" . yank)
              )
              
  (setq term-ansi-default-program "/bin/bash")
;;(setq term-ansi-buffer-name "")
;;(setq term-ansi-buffer-base-name "")

  (define-key term-raw-map (kbd "C-v") (kbd "S-<insert>"))

  (define-key term-mode-map (kbd "C-v") (term-send-raw-string (kbd "S-<insert>")))

(define-key term-mode-map (kbd "C-j") 'term-char-mode)
(define-key term-raw-map (kbd "C-j") 'term-line-mode)


(defun sboo-term-send-shift-insert ()
  "Send « <S-insert> » (“paste”) under `term-mode'."
  (term-send- (kbd "S-<insert>")))


  (define-key term-mode-map (kbd "C-v") #'sboo-term-send-shift-insert)



#------------------------------------------------#
# Info ------------------------------------------#
#------------------------------------------------#

print-builtin-symbols:

	@mkdir -p ./share

	$(Emacs) --no-site-file --no-init-file --script ./bin/print-builtin-symbols > ./share/builtin-symbols.txt

	@wc -l < ./share/builtin-symbols.txt

.PHONY: print-builtin-symbols


==============================================

(use-package lisp-mode

  :hook ((emacs-lisp-mode lisp-mode)
         . (lambda () (add-hook 'after-save-hook 'check-parens nil t)))

  :init
  (dolist (mode '(ielm-mode
                  inferior-emacs-lisp-mode
                  inferior-lisp-mode
                  lisp-interaction-mode
                  lisp-mode
                  emacs-lisp-mode))
    (font-lock-add-keywords
     mode
     '(("(\\(lambda\\)\\>"
        (0 (ignore
            (compose-region (match-beginning 1)
                            (match-end 1) ?λ))))
       ("(\\(ert-deftest\\)\\>[         '(]*\\(setf[    ]+\\sw+\\|\\sw+\\)?"
        (1 font-lock-keyword-face)
        (2 font-lock-function-name-face
           nil t))))))






(use-package eldoc

  :diminish (eldoc-mode)

  :hook ((c-mode-common emacs-lisp-mode) . eldoc-mode)

  )



(use-package grep

  :bind (("M-s n" . find-name-dired)
         ("M-s F" . find-grep)
         ("M-s G" . grep)
         ("M-s d" . find-grep-dired)
        )

  :config

  ())




(use-package align

  :commands align

  ;; mnemonic:
  ;; • "s-e" — personal keymap for EDITING stuff.
  ;; • "[" — the Open-Square-Bracket looks vertical, which implies Vertical-Alignment (?)

  :bind ((""s-e [ c"   . align-code)
         ("s-e [ r" . align-regexp)
        )

  :preface
  (defun align-code (beg end &optional arg)
    (interactive "rP")
    (if (null arg)
        (align beg end)
      (let ((end-mark (copy-marker end)))
        (indent-region beg end-mark nil)
        (align beg end-mark))))

  :config

  ())



(use-package eshell

  :commands (eshell eshell-command)

  :preface

  (defvar eshell-isearch-map
    (let ((map (copy-keymap isearch-mode-map)))
      (define-key map [(control ?m)] 'eshell-isearch-return)
      (define-key map [return]       'eshell-isearch-return)
      (define-key map [(control ?r)] 'eshell-isearch-repeat-backward)
      (define-key map [(control ?s)] 'eshell-isearch-repeat-forward)
      (define-key map [(control ?g)] 'eshell-isearch-abort)
      (define-key map [backspace]    'eshell-isearch-delete-char)
      (define-key map [delete]       'eshell-isearch-delete-char)
      map)
    "Keymap used in isearch in Eshell.")

  :config

  ())


(use-package hl-line

  :commands (hl-line-mode)

  :hook (prog-mode . hl-line-mode)
  )

; "hl-line" abbreviates "[H]igh[L]ight [LINE]".



(use-package image-file

  :defer 5

  :config

  (auto-image-file-mode +1)

  (add-hook 'image-mode-hook #'image-transform-reset)
  (add-hook 'image-mode-hook #'auto-revert-mode)

  ;; ^ Images are Read-Only, hence Auto-Revert them.

 ())

;; http://ergoemacs.org/emacs/emacs_view_images.html


(use-package isearch
  :no-require t

  :bind (:map isearch-mode-map
              ("C-c" . isearch-toggle-case-fold)
              ("C-t" . isearch-toggle-regexp)
              ("C-^" . isearch-edit-string)
              ("C-i" . isearch-complete)
        )

  :config

  ())



(use-package back-button
  :defer 5

  :commands (back-button-mode)

  :init
  (setq back-button-show-toolbar-buttons t)

  :config
  (back-button-mode +1))











(use-package dumb-jump

  :hook ((haskell-mode) . dumb-jump-mode)

  :bind (("s-g p" . dumb-jump-go)
         ("s-g P" . dumb-jump-go-prompt))

  :custom

  (dumb-jump-selector 'helm "disambiguate Multiple Candidates via `helm' (not `popup').")
  (dumb-jump-default-project "~/haskell" "the Default Project if none is found (defaults to « ~» ).")

  :config

  ())

; https://github.com/jacktasia/dumb-jump

(use-package goto-line-preview

  :commands (goto-line-preview)

  :config

  (global-set-key [remap goto-line] #'goto-line-preview)

  ())

; https://github.com/elpa-host/goto-line-preview

;; Inspired by Visual Studio Code goto line preset behavior.




(use-package elint

  :commands (elint-initialize elint-current-buffer)

  ;; mnemonic:
  ;; • "s-m" — personal keymap for MODE-specific stuff.
  ;; • "l" — LINTING.

  :bind (("s-m l" . sboo-elint-buffer))

  :preface
  (defun sboo-elint-buffer ()
    (interactive)
    (when (derived-mode-p 'emacs-lisp-mode major-mode)
      (elint-initialize)
      (elint-current-buffer)))

  :config
  (dolist (SYMBOL '(current-prefix-arg command-line-args-left buffer-file-coding-system emacs-major-version window-system))
    (add-to-list 'elint-standard-variables SYMBOL))

  ())

(use-package elisp-docstring-mode

  :commands (elisp-docstring-mode)

  :config

  ())

; sboo-elisp-docstring-edit-indirect

;; `major-mode' for editing Emacs Lisp Docstrings.
;;
;; Provides:
;;
;; • Highlighting — via `font-lock'.
;; • Escaping — of quotes and backslashes.
;;

; https://github.com/Fuco1/elisp-docstring-mode




(use-package helm-sys
  :commands helm-top)

(use-package helm-font
  :commands (helm-select-xfont helm-ucs))

(use-package helm-google
  :commands helm-google)






(use-package hi-lock

  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase))
  )


(use-package highlight-cl

  :hook (emacs-lisp-mode . highlight-cl-add-font-lock-keywords)

  )

; https://github.com/emacsmirror/highlight-cl




(use-package diff-mode

  :commands (diff-mode)

 ;;TODO? :mode (rx "." (or "diff" "patch"))

  :config

  ())

(use-package diff-hl
  :commands (diff-hl-mode diff-hl-dired-mode)
  :hook (magit-post-refresh . diff-hl-magit-post-refresh))

(use-package diff-hl-flydiff
  :commands diff-hl-flydiff-mode)

(use-package dockerfile-mode

  :mode "Dockerfile[a-zA-Z.-]*\\'" ; (rx bos "Dockerfile" (0+ (char ".-" alpha)) eos)

  :config

  ())



(use-package edit-indirect

  :commands (edit-indirect-region) 

  ;; mnemonic:
  ;; • "s-e" — personal keymap for EDITING stuff.
  ;; • "i" — « edit-INDIRECT »

  :bind (("s-e i" . sboo-edit-indirect-dwim))

  :config

(defun sboo-edit-indirect-dwim ()
   "`edit-indirect-region'; otherwise, the current string or codeblock or quasiquote."
    (interactive)

    (let* (()
        )

  ())

; sboo-mark-string
; sboo-mark-doc
; sboo-html-mark-codeblock
; sboo-markdown-mark-codeblock
; sboo-haskell-mark-quasiquote



(use-package edit-rectangle

  :bind ("C-x r e" . edit-rectangle)

  :config

  ())

(use-package edit-var

  :commands (edit-variable) 

  :bind ("C-c e v" . edit-variable)

  :config

  ())


(use-package deft

  :commands (deft deft-new-file)

  :bind ("C-, C-," . deft)

  :config

  ())


(use-package ediff

  ;; mnemonic:
  ;; • "s-r" — personal keymap for RUNNING stuff.
  ;; • "=" — “whether two things are EQUAL.”

  :bind (("s-r = b" . ediff-buffers)
         ("s-r = B" . ediff-buffers3)
         ("s-r = c" . compare-windows)
         ("s-r = =" . ediff-files)
         ("s-r = f" . ediff-files)
         ("s-r = F" . ediff-files3)
         ("s-r = m" . count-matches)
         ("s-r = r" . ediff-revision)
         ("s-r = p" . ediff-patch-file)
         ("s-r = P" . ediff-patch-buffer)
         ("s-r = l" . ediff-regions-linewise)
         ("s-r = w" . ediff-regions-wordwise))

  :config

  ())


(use-package edit-server

  :if (and window-system
           (sboo-emacs-secondary-p))

  :config
  (edit-server-start)
  ())

(use-package engine-mode

  :config

  (defengine google "https://www.google.com/search?q=%s"
    :keybinding "/")

  (engine-mode +1))

; https://github.com/hrs/engine-mode



  :mode (("\\.hs\\(c\\|-boot\\)?\\'" . haskell-mode)
         ("\\.lhs\\'" . literate-haskell-mode)
         ("\\.cabal\\'" . haskell-cabal-mode))

  ;; mnemonic:
  ;; • "s-i" — personal keymap for INSERTING stuff.

  :bind (:map haskell-mode-map
              ("s-i u" . sboo-haskell-insert-undefined)
             )

  :preface
  (defun sboo-haskell-insert-undefined ()
    "`insert' « undefined » (e.g. during development.)"
    (interactive)
    (insert "undefined"))


(use-package json-reformat
  :after json-mode

  :commands (json-reformat)

  :config
  ())

(use-package flycheck
  :commands (flycheck-mode
             flycheck-next-error
             flycheck-previous-error)
  :init
  (dolist (where '((emacs-lisp-mode-hook . emacs-lisp-mode-map)
                   (haskell-mode-hook    . haskell-mode-map)
                   (js2-mode-hook        . js2-mode-map)
                   (c-mode-common-hook   . c-mode-base-map)))
    (add-hook (car where)
              `(lambda ()
                 (bind-key "M-n" #'flycheck-next-error ,(cdr where))
                 (bind-key "M-p" #'flycheck-previous-error ,(cdr where)))))






(use-package graphviz-dot-mode

  :commands (graphviz-dot-mode)

  :mode "\\.dot\\'"

  :config
  ())

; https://github.com/ppareit/graphviz-dot-mode

(use-package jq-mode

  :commands (jq-mode jq-interactively)

  :mode "\\.jq\\'"

  :config

  (with-eval-after-load "json-mode"
    (define-key json-mode-map (kbd "s-m m j q") #'jq-interactively))

  ())

; https://github.com/ljos/jq-mode

;; « M-x `jq-interactively' »:
;;
;; • runs the query (which was entered into the minibuffer) iteratively over the JSON buffer.
;;

(use-package llvm-mode

  :mode "\\.ll\\'"

  )

; https://github.com/llvm-mirror/llvm/blob/master/utils/emacs/llvm-mode.el

(use-package lua-mode

  :mode "\\.lua\\'"
  :interpreter "lua"

  )

; https://github.com/immerrr/lua-mode
; https://immerrr.github.io/lua-mode/

(use-package makefile-runner

  :commands (makefile-runner)

  :config
  ())

; https://github.com/danamlund/emacs-makefile-runner
; http://danamlund.dk/emacs/make-runner.html

(use-package know-your-http-well

  :commands (http-header
             http-method
             http-relation
             http-status-code
             media-type)

  :config
  ())

; https://github.com/for-GET/know-your-http-well

(use-package mediawiki

  :commands (mediawiki-open)

  :config
  ())

; https://github.com/hexmode/mediawiki-el

(use-package nroff-mode

  :commands (nroff-mode)

  :config
  ())

; 








(use-package magit
  :bind (("C-x g" . magit-status)
         ("C-x G" . magit-status-with-prefix))
  :bind (:map magit-mode-map
              ("U" . magit-unstage-all)
              ("M-h") ("M-s") ("M-m") ("M-w"))
  :bind (:map magit-file-section-map ("<C-return>"))
  :bind (:map magit-hunk-section-map ("<C-return>"))
  :preface
  ;; History can be viewed with:
  ;; git log refs/snapshots/$(git symbolic-ref HEAD)
  (defun magit-monitor (&optional no-display)
    "Start git-monitor in the current directory."
    (interactive)
    (let* ((path (file-truename
                  (directory-file-name
                   (expand-file-name default-directory))))
           (name (format "*git-monitor: %s*"
                         (file-name-nondirectory path))))
      (unless (and (get-buffer name)
                   (with-current-buffer (get-buffer name)
                     (string= path (directory-file-name default-directory))))
        (with-current-buffer (get-buffer-create name)
          (cd path)
          (ignore-errors
            (start-process "*git-monitor*" (current-buffer)
                           "git-monitor" "-d" path))))))

  (defun magit-status-with-prefix ()
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'magit-status)))

  (defun endless/visit-pull-request-url ()
    "Visit the current branch's PR on Github."
    (interactive)
    (browse-url
     (format "https://github.com/%s/pull/new/%s"
             (replace-regexp-in-string
              "\\`.+github\\.com:\\(.+?\\)\\(\\.git\\)?\\'" "\\1"
              (magit-get "remote" (magit-get-remote) "url"))
             (magit-get-current-branch))))

  :hook (magit-mode . hl-line-mode)
  :config
  (use-package magit-commit
    :config
    (use-package git-commit))

  (use-package magit-files
    :config
    (global-magit-file-mode))

  (add-hook 'magit-status-mode-hook #'(lambda () (magit-monitor t)))

  (define-key magit-mode-map "G" #'endless/visit-pull-request-url)

  (eval-after-load 'magit-pull
    '(transient-insert-suffix 'magit-pull "p"
       '("F" "default" magit-fetch-from-upstream)))

  (eval-after-load 'magit-push
    '(transient-insert-suffix 'magit-push "p"
       '("P" "default" magit-push-current-to-upstream))))






(use-package latex

  :after auctex

  :config

  (require 'preview)

  (load (emacs-path "site-lisp/auctex/style/minted"))

  (info-lookup-add-help :mode 'LaTeX-mode
                        :regexp ".*"
                        :parse-rule "\\\\?[a-zA-Z]+\\|\\\\[^a-zA-Z]"
                        :doc-spec '(("(latex2e)Concept Index")
                                    ("(latex2e)Command Index")))

  ())


(use-package link-hint
  :defer 10
  :bind ("C-c C-o" . link-hint-open-link)
  :config
  (add-hook 'eww-mode-hook
            #'(lambda () (bind-key "f" #'link-hint-open-link eww-mode-map)))
  (add-hook 'w3m-mode-hook
            #'(lambda () (bind-key "f" #'link-hint-open-link w3m-mode-map))))

; https://github.com/noctuid/link-hint.el

(use-package mmm-mode

  :commands (mmm-mode)

  :config
  ())

; "mmm" abbreviates "[M]ultiple [M]ajor [M]odes".

; https://github.com/purcell/mmm-mode

(use-package operate-on-number

  :bind ("s-e n" . operate-on-number-at-point)

  :config
  ())

; https://github.com/knu/operate-on-number.el





==============================================


* dumb-jump
* elisp-docstring-mode
* goto-line-preview
* graphviz-dot-mode
* highlight-cl
* jq-mode
* know-your-http-well
* link-hint
* llvm-mode
* lua-mode
* makefile-runner
* mediawiki
* operate-on-number
* pandoc-mode
* selected
* sort-words
* string-edit
* string-inflection
* xah-lookup

------------------------------------------------

;; (defmacro sboo-key (keys-to-bind command-to-be-bound &optional keymap-to-bind-in)

;;   (if (fboundp #'bind-key)

;;       (bind-key keys-to-bind command-to-be-bound keymap-to-bind-in)

;;     (if keymap-to-bind-in

;;         `(define-key keymap-to-bind-in ,(kbd keys-to-bind) ,(function command-to-be-bound))

;;       `(global-set-key ,(kbd keys-to-bind) ,(function command-to-be-bound)))

;;     ;;(define-key (current-global-map)

;;     (define-key keymap-to-bind-in (kbd keys-to-bind) (function command-to-be-bound))

;;     (global-set-key (kbd keys-to-bind) (function command-to-be-bound))))

;; M-: (sboo-key "<s>-c" sboo-insert-char)

==============================================

(use-package latex

  :after auctex

  :config

  (require 'preview)

  (load (emacs-path "site-lisp/auctex/style/minted"))

  (info-lookup-add-help :mode 'LaTeX-mode
                        :regexp ".*"
                        :parse-rule "\\\\?[a-zA-Z]+\\|\\\\[^a-zA-Z]"
                        :doc-spec '(("(latex2e)Concept Index")
                                    ("(latex2e)Command Index")))

  ())

(use-package link-hint
  :defer 10

  :bind (:map sboo-navigate-keymap
              ("C-c l o" . link-hint-open-link)
              ("C-c l c" . link-hint-copy-link)
         )

  :config

  ())

;; ^ Links:
;;
;;   • URL `https://github.com/noctuid/link-hint.el'
;;


;;----------------------------------------------;;
;; Thing at point ------------------------------;;
;;----------------------------------------------;;

(defun sboo-indent-defun-or-buffer ()

  "Indent the `defun' currently-surrounding `point', or the `current-buffer'."

  (interactive)

  (let* ((BOUNDS (bounds-of-thing-at-point 'defun))
         )

    (if BOUNDS
        (indent-region (car BOUNDS) (cdr BOUNDS))
      (indent-region (point-min) (point-max)))))
      
==============================================

(flush-lines "^\\s-*$" (point-min) (point-max))

------------------------------------------------

*Vendored Dependencies* include:

- `./highlight-*`
- ``./rainbow-*`

------------------------------------------------


  ;;--------------------------;;

  :preface

  (defun sboo-selected-global-mode (&optional argument)

    "Conditional `selected-global-mode'.

Inputs:

• ARGUMENT — a `booleanp' or `integerp'.
  whether to enable `selected-minor-mode' (nil or `positivep')
  or to disable it (0 or `negativep')."

    (let* (
           )

      ))

  ;;--------------------------;;

  :config

  (sboo-selected-global-mode +1))

------------------------------------------------

(defun sboo-edit-indirect-region (beg end)

  "Edit region from BEG to END.

Related:

• `edit-indirect-region'
• `markdown-edit-code-block'"

  (interactive "r")

  (let* (
         )

    (cond

     ((derived-mode-p 'markdown-mode)
      (sboo-markdown-edit-code-block))

     (t
      (edit-indirect-region beg end)))))


;;----------------------------------------------;;

(defun sboo-markdown-edit-code-block ()

  "Edit Markdown code block in an indirect buffer."

  (interactive)

  (save-excursion
    (if (fboundp 'edit-indirect-region)
        (let* ((bounds (markdown-get-enclosing-fenced-block-construct))
               (begin (and bounds (goto-char (nth 0 bounds)) (point-at-bol 2)))
               (end (and bounds (goto-char (nth 1 bounds)) (point-at-bol 1))))
          (if (and begin end)
              (let* ((lang (markdown-code-block-lang))
                     (mode (or (and lang (markdown-get-lang-mode lang))
                               markdown-edit-code-block-default-mode))
                     (edit-indirect-guess-mode-function
                      (lambda (_parent-buffer _beg _end)
                        (funcall mode))))
                (edit-indirect-region begin end 'display-buffer))
            (user-error "Not inside a GFM or tilde fenced code block")))
      (when (y-or-n-p "Package edit-indirect needed to edit code blocks. Install it now? ")
        (progn (package-refresh-contents)
               (package-install 'edit-indirect)
               (markdown-edit-code-block))))))

------------------------------------------------

(progn

;;(global-set-key (kbd "C-M-a") #')
;;(global-set-key (kbd "C-M-b") #')
;;(global-set-key (kbd "C-M-c") #')
;;(global-set-key (kbd "C-M-d") #')
;;(global-set-key (kbd "C-M-e") #')
;;(global-set-key (kbd "C-M-f") #')
;;(global-set-key (kbd "C-M-g") #')
;;(global-set-key (kbd "C-M-h") #')
;;(global-set-key (kbd "C-M-i") #')
;;(global-set-key (kbd "C-M-j") #')
;;(global-set-key (kbd "C-M-k") #')
;;(global-set-key (kbd "C-M-l") #')
;;(global-set-key (kbd "C-M-m") #')
;;(global-set-key (kbd "C-M-n") #')
;;(global-set-key (kbd "C-M-o") #')
;;(global-set-key (kbd "C-M-p") #')
;;(global-set-key (kbd "C-M-q") #')
;;(global-set-key (kbd "C-M-r") #')
;;(global-set-key (kbd "C-M-s") #')
;;(global-set-key (kbd "C-M-t") #')
;;(global-set-key (kbd "C-M-u") #')
;;(global-set-key (kbd "C-M-v") #')
;;(global-set-key (kbd "C-M-w") #')
;;(global-set-key (kbd "C-M-x") #')
;;(global-set-key (kbd "C-M-y") #')
;;(global-set-key (kbd "C-M-z") #')

  ())

------------------------------------------------

  (cl-defmacro defun-unicode (name char-value char-name &key doc)

    "Define a command which `insert's a unicode character.

• NAME — (unquoted) `symbolp'.
  the function name.
• CHAR-VALUE — a `characterp'.
  a Unicode Character.
• CHAR-NAME — a `stringp'.
  a Unicode Character Name.
• DOC — a `stringp'.
  the function documentation.
  (defaults to the empty string.)
  
------------------------------------------------

;; (defmacro sboo-key (keys-to-bind command-to-be-bound &optional keymap-to-bind-in)

;;   (if (fboundp #'bind-key)

;;       (bind-key keys-to-bind command-to-be-bound keymap-to-bind-in)

;;     (if keymap-to-bind-in

;;         `(define-key keymap-to-bind-in ,(kbd keys-to-bind) ,(function command-to-be-bound))

;;       `(global-set-key ,(kbd keys-to-bind) ,(function command-to-be-bound)))

;;     ;;(define-key (current-global-map)

;;     (define-key keymap-to-bind-in (kbd keys-to-bind) (function command-to-be-bound))

;;     (global-set-key (kbd keys-to-bind) (function command-to-be-bound))))

;; M-: (sboo-key "<s>-c" sboo-insert-char)
------------------------------------------------

(use-package lisp-mode

  :hook ((emacs-lisp-mode lisp-mode) . (lambda () (add-hook 'after-save-hook 'check-parens nil t)))

  :init

  (dolist (mode '(ielm-mode
                  inferior-emacs-lisp-mode
                  inferior-lisp-mode
                  lisp-interaction-mode
                  lisp-mode
                  emacs-lisp-mode))
    (font-lock-add-keywords
     mode
     '(("(\\(lambda\\)\\>"
        (0 (ignore
            (compose-region (match-beginning 1)
                            (match-end 1) ?λ))))
       ("(\\(ert-deftest\\)\\>[         '(]*\\(setf[    ]+\\sw+\\|\\sw+\\)?"
        (1 font-lock-keyword-face)
        (2 font-lock-function-name-face
           nil t)))))

  :config ())
  
------------------------------------------------

(use-package edit-indirect

  :commands (edit-indirect-region) 

  ;; mnemonic:
  ;; • "s-e" — personal keymap for EDITING stuff.
  ;; • "i" — « edit-INDIRECT »

  :bind (("s-e i" . sboo-edit-indirect-dwim))

  :config ())

------------------------------------------------

/* -------------------------------------------- */
/* Functions ---------------------------------- */
/* -------------------------------------------- */

function sbooHandleHelp (event) {
    'use strict';

    const keyName = event.key || event.keyIdentifier;
    const keyCode = event.which || event.code || event.keyCode;

    const isControl = event.ctrlKey;
    const isAlt     = event.altKey;
    const isShift   = event.shiftKey;

  console.log("");
  console.log(keyName);
  console.log(keyCode);

 // console.log("");
 // console.log(keyName);
 // console.log(keyCode);

    if (sbooIsKeyH(keyName, keyCode) && (isControl && isAlt && isShift)) {

        alert(sbooHelpMessage);

    }
}

/* -------------------------------------------- */

function sbooIsKeyH (keyName, keyCode) {
    'use strict';

    return (keyName === "h" || keyName === "H" || keyCode == 104 || keyCode == 72);

}

------------------------------------------------


  (defun sboo-string-inflection-haskell-style-cycle-function (str)
    "Cycle WORD between « fooBar ⇒ FooBar ⇒ foo_bar ⇒ FOO_BAR ⇒ ... »

Inputs:

• WORD — a `stringp'.

Output:

• a `stringp'."

    (cond
     ((string-inflection-underscore-p word)
      (string-inflection-upcase-function       word))
     ((string-inflection-camelcase-p word)
      (string-inflection-upcase-function       word))
     ((string-inflection-upcase-p word)
      (string-inflection-pascal-case-function  word))
     (t
      (string-inflection-camelcase-function    word))))

  (defun sboo-string-inflection-haskell-style-cycle ()
    "`string-inflection-all-cycle' for Haskell (identifiers & constructors).

Related:

• calls `sboo-string-inflection-haskell-style-cycle-function'"

    (interactive)
    (string-inflection-insert
     (sboo-string-inflection-haskell-style-cycle-function
      (string-inflection-get-current-word))))

------------------------------------------------
  (add-hook 'ruby-mode-hook #'sboo-bind-string-inflection-cycle)
          '(lambda ()
             (local-set-key (kbd "C-c C-u") 'string-inflection-ruby-style-cycle)))

(add-hook 'java-mode-hook
          '(lambda ()
             (local-set-key (kbd "C-c C-u") 'string-inflection-java-style-cycle)))

(add-hook 'python-mode-hook
          '(lambda ()
             (local-set-key (kbd "C-c C-u") 'string-inflection-python-style-cycle)))

------------------------------------------------
(defun string-inflection-all-cycle-function (str)
  "foo_bar => FOO_BAR => FooBar => fooBar => foo-bar => Foo_Bar => foo_bar
   foo     => FOO     => Foo    => foo"
  (cond
   ;; foo => FOO
   ((string-inflection-word-p str)
    (string-inflection-upcase-function str))
   ;; foo_bar => FOO_BAR
   ((string-inflection-underscore-p str)
    (string-inflection-upcase-function str))
   ;; FOO_BAR => FooBar
   ((string-inflection-upcase-p str)
    (string-inflection-pascal-case-function str))
   ;; FooBar => fooBar
   ;; Foo    => foo
   ((string-inflection-pascal-case-p str)
    (string-inflection-camelcase-function str))
   ;; fooBar => foo-bar
   ((string-inflection-camelcase-p str)
    (string-inflection-kebab-case-function str))
   ;; foo-bar => Foo_Bar
   ((string-inflection-kebab-case-p str)
    (string-inflection-capital-underscore-function str))
   ;; foo-bar => foo_bar
   (t
    (string-inflection-underscore-function str))))

------------------------------------------------


    (cond

     ;; « foobar ⇒ foobar »:

     ((string-inflection-camelcase-p word)
      (string-inflection-pascal-case word))

     ;; « foo_bar ⇒ FOO_BAR »:

     ((string-inflection-underscore-p    word)
      (string-inflection-upcase-function word))

     ;; « foobar ⇒ foobar »:

     ((string-inflection-upcase-p             word)
      (string-inflection-pascal-case-function word))

     ;; « * ⇒ fooBar »:

     (t
      (string-inflection-lower-camelcase-function word))))


;;----------------------------------------------;;

(use-package typo

  :commands (typo-mode)

  :delight (typo-mode)

  :hook (text-mode . typo-mode)

  :config

  ;;(setq-default typo-language )

  (typo-global-mode +1))

------------------------------------------------

* `flycheck.el`               — `;; Package-Requires: ((dash "2.12.1") (let-alist "1.0.4"))`

------------------------------------------------
(use-package diff-hl
  :commands (diff-hl-mode diff-hl-dired-mode)
  :hook (magit-post-refresh . diff-hl-magit-post-refresh))

(use-package diff-hl-flydiff
  :commands diff-hl-flydiff-mode)

------------------------------------------------

(column-number-mode +1)

;; ^ always show Column Numbers in the Modeline (by default, only Row Numbers are shown).

------------------------------------------------

(defun sboo-english-words (&optional force)

  "Accessor for variable `sboo-english-words'.

Inputs:

• FORCE — a `booleanp'.
  whether to force reloading the dictionary (via `sboo-load-dictionary-words')
  and reinitializing the cache variable `sboo-english-words'.

Output:

• a `listp' of `stringp's."

  (if (and sboo-english-words (not force))
      sboo-english-words

    (let* ((WORDS-DEFAULT (sboo-load-dictionary-words))
           (WORDS-EXTRA   sboo-english-extra-words)
           (WORDS (append ))
           )

      (setq sboo-english-words WORDS)

      WORDS)))
------------------------------------------------
(defun sboo-english-words-completion-at-point ()

  "`completion-at-point' for `sboo-english-words'.

Links:

• URL `https://emacs.stackexchange.com/questions/15276/how-do-i-write-a-simple-completion-at-point-functions-function'"

  (interactive)

  (when-let* ((BOUNDS (bounds-of-thing-at-point 'word))
              (BEG (car BOUNDS))
              (END (cdr BOUNDS))
              )

    (list BEG
          END
          (sboo-english-words)

          :exclusive 'no

          :company-docsig #'identity
          :company-doc-buffer (lambda (CANDIDATE)
                                (company-doc-buffer (format "« %s » is defined in « %s »'" CANDIDATE sboo-english-dictionary-file)))
          :company-location (lambda (CANDIDATE)
                              (with-current-buffer (find-file-noselect sboo-english-dictionary-file)
                                (goto-char (point-min))
                                (cons (current-buffer) (search-forward CANDIDATE nil t)))))))

------------------------------------------------

;;----------------------------------------------;;

(use-package json-reformat
  :after json-mode

  :commands (json-reformat-region)

  :config ())

;; ^ Links:
;;
;;   • URL `https://github.com/gongo/json-reformat'
;;
------------------------------------------------

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
**Table of Contents**

- [Refine](#refine)
    - [Usage examples](#usage-examples)
    - [Limitations](#limitations)
    - [Keybindings](#keybindings)
    - [Installation](#installation)
    - [Tests](#tests)
    - [Related projects](#related-projects)

<!-- markdown-toc end -->

------------------------------------------------

------------------------------------------------

------------------------------------------------

------------------------------------------------

------------------------------------------------


==============================================








==============================================




















==============================================










































































==============================================































































































##################################################

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

