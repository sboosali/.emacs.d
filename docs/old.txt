;;; -*- lexical-binding: t -*-

;;==============================================;;
;;; Commentary:

;; Completion for Unicode Character Names.
;;
;; • `sboo-ucs-names-table' — the primary Unicode data structure.
;; • `sboo-read-character-name' — the primary completion function.
;;
;; 

;;==============================================;;
;;; Code:

;;----------------------------------------------;;
;; Imports -------------------------------------;;
;;----------------------------------------------;;

;; Builtins:

(require 'cl)     ;; "CommonLisp"
(require 'subr-x) ;; "SUBRoutine-eXtRAS"
(require 'mule)   ;; "MUltiLingual Environment"

;;----------------------------------------------;;
;; Variables -----------------------------------;;
;;----------------------------------------------;;

(defvar sboo-ucs-names-table

  nil

  "Hash-Table from Unicode Character names to Unicode Character codepoints.

« ucs » abbreviates « Unicode CharacterS(?) ».

Examples:

• M-: (message \"%c\" (gethash \"LATIN SMALL LETTER ALPHA\" sboo-ucs-names-table))
    ⇒ \"ɑ\"

Accessed by Function `sboo-ucs-names-table'.")

;;----------------------------------------------;;

(defvar sboo-ucs-names-list

  nil

  "List of Unicode Character names.

Examples:

• M-: (nth 891 sboo-ucs-names-list)
    ⇒ \"LATIN SMALL LETTER ALPHA\"

Related:

• `sboo-unicode--'

Accessed by Function `sboo-ucs-names-list'.")

;;----------------------------------------------;;

(defvar sboo-ucs-names-interesting-list

  nil

  "List of Unicode Character names, filtering away “boring” characters (like ASCII).

Related:

• `sboo-unicode--interesting-character-p'")

;;----------------------------------------------;;

(defvar sboo-ucs-names-annotated-list

  nil

  "List of Unicode Character names, annotated with their namesake-characters.

Examples:

• M-: (nth 891 sboo-ucs-names-annotated-list)
    ⇒ \"ɑ LATIN SMALL LETTER ALPHA\"

Related:

• `sboo-unicode--annotate-character-p'

Displayed by Function `sboo-read-character-name'.

Like `sboo-ucs-names-list', but each name is prefixed by the namesake character (plus a space).")

;;----------------------------------------------;;

(defcustom sboo-unicode-completion-annotate

  t

  "Whether to display the unicode character itself (beside the name), during completion.

Type:

• a `booleanp'.

Related:

• `sboo-read-character-by-name'.

For example, `sboo-unicode-completion-annotate' toggles whether `sboo-read-character-by-name' displays:

• \"LATIN SMALL LETTER ALPHA\"   (if nil)
• \"ɑ LATIN SMALL LETTER ALPHA\" (if t)"

  :type '(boolean)

  :safe  t
  :group 'sboo)

;;----------------------------------------------;;

(defcustom sboo-unicode-completion-namesake-divider

  "  "

  "Divider between a character and its name, in `sboo-read-character-name' (a `stringp')."

  :type '(choice (string  :tag "Literal text")
                 (integer :tag "Number of spaces")
                 (const nil :tag "No divider")) ;TODO or "Fallback to default"?

  ;;:set ;TODO set dirty flag (property?)

  :safe  t
  :group 'sboo)

;;----------------------------------------------;;
;; Functions: Accessors ------------------------;;
;;----------------------------------------------;;

(cl-defun sboo-ucs-names-table (&key refresh)

  "Return a mapping of Unicode Character names to Unicode Character codepoints.

Initializes Variable `sboo-ucs-names-table'.

Inputs:

• REFRESH — a `booleanp'.
  If non-nil, rebuild Variable `sboo-ucs-names-table' from `ucs-names'
  (even if they've already been initialized to a non-nil `hash-table-p').

Output:

• a `hash-table-p' from `stringp's to `integerp's.

Examples:

• M-: (sboo-ucs-names-table :refresh t)
    ⇒ #s(hash-table size 42943 test equal rehash-size 1.5 rehash-threshold 0.8125 data (\"NULL\" 0 ... ))

Related:

• `ucs-names'

Notes:

• `ucs-names' is a `hash-table-p' on Emacs≥26 and an alist on Emacs≤25."

  (progn

    ;; Initialize:

    (when (or refresh
              (not sboo-ucs-names-table))

      (let* ((OBJECT (ucs-names))
             (TYPE   (type-of OBJECT))
             (TABLE  (pcase TYPE
                       ('hash-table OBJECT)
                       ('list       (sboo/alist->table OBJECT :test #'equal :size 43000))
                       (_           nil)))
             )

        (setq sboo-ucs-names-table TABLE)))
    
    ;; Access:

    sboo-ucs-names-table))

;;----------------------------------------------;;

(cl-defun sboo-ucs-names-list (&key refresh annotate)

  "Return all Unicode Character names.

Inputs:

• REFRESH — a `booleanp'.
  If non-nil, rebuild the « sboo-ucs-names-* » variables
  (i.e. Variable `sboo-ucs-names-list', Variable `sboo-ucs-names-annotated-list')
  from `ucs-names', even if they've already been initialized (to a non-nil `listp').
• ANNOTATE — a `booleanp'.
  Whether to return Variable `sboo-ucs-names-list' or Variable `sboo-ucs-names-annotated-list'.

Output:

• a `listp' of `stringp's.

Examples:

• M-: (sboo-ucs-names-list)
    ⇒ (\"NULL\" ... \"BULLET\" ...)

• M-: (sboo-ucs-names-list :annotate t)
    ⇒ (\"  NULL\" ... \"• BULLET\" ...)

Related:

• `ucs-names'

Notes:

• `ucs-names' is a `hash-table-p' on Emacs≥26 and an alist on Emacs≤25."

  (progn

    ;; Initialize:

    (when (or refresh
              (not (and sboo-ucs-names-list
                        sboo-ucs-names-annotated-list)))

      (let* ((TABLE (sboo-ucs-names-table :refresh refresh))
             (NAMES (hash-table-keys TABLE))
             )

        (progn

          (setq sboo-ucs-names-list NAMES)

          (setq sboo-ucs-names-annotated-list
                (mapcar #'sboo-unicode--prefix-namesake-character NAMES)))))

    ;; Access:

    (if annotate
        sboo-ucs-names-annotated-list
      sboo-ucs-names-list)))

;;----------------------------------------------;;

(defun sboo-unicode-completion-namesake-divider-string ()

  "Accessor for Variable `sboo-unicode-completion-namesake-divider'.

Output:

• a `stringp'."

  (let* ((OBJECT sboo-unicode-completion-namesake-divider)
         )

  (pcase OBJECT

    ((pred stringp)  OBJECT)
    ((pred integerp) (make-string OBJECT ?\ ))
    ('nil            nil)

    (_ " "))))

;; ^ NOTE «  ?\  » is a space literal character.

;;----------------------------------------------;;

(defun sboo-unicode-completion-namesake-divider-length ()

  "Accessor for Variable `sboo-unicode-completion-namesake-divider'.

Output:

• an `integerp'."

  (let* ((OBJECT sboo-unicode-completion-namesake-divider)
         )

  (pcase OBJECT

    ((pred stringp)  (length OBJECT))
    ((pred integerp) OBJECT)
    ('nil            nil)

    (_ 1))))

;;----------------------------------------------;;
;; Functions -----------------------------------;;
;;----------------------------------------------;;

(defun sboo-ucs-names-get (name)

  "Get the Unicode Character whose name is NAME.

Inputs:

• NAME — a `stringp'.
  The name of a Unicode Character.

Output:

• an `integerp'.
  a Unicode Character codepoint.

Type (Haskell):

• « :: String -> Maybe Char »

Example:

• M-: (format \"%c\" (sboo-ucs-names-get \"BULLET\"))
    ⇒ \"•\"
• M-: (sboo-ucs-names-get \"NOT A UNINCODE CHARACTER NAME\")
    ⇒ nil"

  (let* ((NAME  (upcase name))
         (TABLE (sboo-ucs-names-table))
         (CHAR  (gethash NAME TABLE))
         )

    CHAR))

;; ^ (format "%c" (sboo-ucs-names-get "BULLET"))

;;----------------------------------------------;;

(defun sboo-get-char-name (char)

  "Get the Unicode Character Database « 'name » of CHAR.

Inputs:

• CHAR — a character (an `integerp').

Examples:

    M-: (call-interactively #'sboo-get-char-name)
    Character: c
    ⇒ \"LATIN SMALL LETTER C\"

Related:

• `get-char-code-property'."

  (interactive (list
                (or (condition-case _
                        (sboo-unicode--interesting-character-p (thing-at-point 'char))
                      (error nil))
                    (condition-case _
                        (read-char-exclusive "Character (press a key): ")
                                        ;TODO read 1-length string.
                      (error nil))
                    )))

  (get-char-code-property char 'name))

;;----------------------------------------------;;
;; Commands ------------------------------------;;
;;----------------------------------------------;;

(defun sboo-read-character-name (&optional annotate refresh)

  "Read a Unicode Character name.

Inputs: Keyword Arguments are passed-through to `sboo-ucs-names-list'.

Output:

• a `stringp'.
  a key of `ucs-names'.

Type (Haskell):

• « :: IO String ».

Related:

• `ucs-names'."

  (interactive (list nil
                     (if current-prefix-arg t nil)
                     ))

  (let*  ((ANNOTATE      (or annotate sboo-unicode-completion-annotate))

          (PROMPT        (format "%s: " "Unicode Character name"))
          (REQUIRE-MATCH t)
          (PREDICATE     nil)
          (HISTORY       nil)
          (CANDIDATES    (sboo-ucs-names-list :annotate ANNOTATE :refresh refresh))
          )

    (let* ((STRING (let ((completion-ignore-case t))
                     (completing-read PROMPT CANDIDATES PREDICATE REQUIRE-MATCH nil HISTORY nil nil)))

           (NAME   (if ANNOTATE
                       (sboo-unicode--strip-namesake-character STRING)
                     STRING))
           )

      (string-trim-left NAME))))

;; ^ NOTE `string-trim-left' will trim a `sboo-unicode-completion-namesake-divider' any length.

;;----------------------------------------------;;

(defun sboo-read-character-by-name ()

  "Read a Unicode Character name, returning the corresponding Unicode Character.

Output:

• an `integerp' (a character).
  a value of `ucs-names'.

Type (Haskell):

• « :: IO Char ».

Related:

• `ucs-names'.
• `read-character-by-name' — doesn't support fuzzy-matching."

  (interactive (list
                (if current-prefix-arg t nil)
                ))

  (let* ((STRING (sboo-read-character-name))
         (CHAR   (sboo-ucs-names-get STRING))
         )

    CHAR))

;;----------------------------------------------;;

;;TODO;(cl-defun sboo-insert-unicode-name (name &key display-properties)

(defun sboo-insert-unicode-name ()

  "Read and insert a Unicode Character name.

Output:

• a `stringp'.
  The Unicode Character name that was read and inserted.
  nil if that character didn't satisfy `sboo-unicode--insertable-character-p'.

Type (Haskell):

• « :: IO String ».

Related:

• `sboo-read-character-name'."

  (interactive)

  (let ((STRING (sboo-read-character-name))
        (NAME   (upcase STRING))
        )

    (insert STRING)))

;; M-x (call-interactively #'sboo-insert-unicode-name)

;;----------------------------------------------;;

;;TODO;(cl-defun sboo-insert-char (name &key display-properties)

(defun sboo-insert-char (name)

  "Insert the Unicode Character named `NAME'.

Inputs:

• NAME — a `stringp'. 
         The name of a Unicode Character.

Type (Haskell):

• « :: String -> IO () ».

Notes:

• `sboo-insert-char' is like `insert-char', but:

    • its completion is more flexible (for example, `helm' can be configured to efficiently fuzzily-match)
    • it displays the literal unicode character itself alongside each name (when `sboo-unicode-completion-annotate' is non-nil).

Related:

• `sboo-unicode-completion-annotate'.
• `sboo-read-character-name'.
• `sboo-ucs-names-get'."

  (interactive (list (sboo-read-character-name)
                     ))

  (let* ((NAME name)
         (CHAR (sboo-ucs-names-get NAME))
         )

    (pcase CHAR

      ('nil              nil)
      ((pred stringp)    (insert      CHAR))
      ((pred characterp) (insert-char CHAR))

      (_ (error "sboo-insert-char")))))

;; M-x (call-interactively #'sboo-insert-char) 

;;----------------------------------------------;;
;; Utilities -----------------------------------;;
;;----------------------------------------------;;

(cl-defun sboo-unicode--prefix-namesake-character (name)

  "Prefix NAME with the character it names.

Inputs:

• NAME — a `stringp'. The name of the unicode character.

Output:

• a `stringp'. 
  the output `length' will always be exactly two more than the input's.

Some characters aren't displayed, including:

• non-printable characters (e.g. NULL)
• ascii characters (e.g. LATIN SMALL LETTER A)

Examples:

    M-: (sboo-unicode--prefix-namesake-character \"BULLET\")
      ⇒ \"•  BULLET\"

    M-: (sboo-unicode--prefix-namesake-character \"SKULL\")
      ⇒ \"💀  SKULL\"

    M-: (sboo-unicode--prefix-namesake-character \"NULL\")
      ⇒ \"   NULL\"

    M-: (equal (substring (sboo-unicode--prefix-namesake-character \"NULL\") (sboo-unicode-completion-namesake-divider-length)) \"NULL\")
      ⇒ t

    M-: (= (sboo-unicode-completion-namesake-divider-length) (- (length (sboo-unicode--prefix-namesake-character \"NULL\")) (length \"NULL\"))
      ⇒ t"

  (let* ((CHAR    (sboo-ucs-names-get name))
         (DIV     (sboo-unicode-completion-namesake-divider-string))
         )

    (if DIV

        (let* ((STRING (if (and CHAR (sboo-unicode--annotate-character-p CHAR))
                           (char-to-string CHAR)
                         " "))
               )
          (concat STRING DIV name))

      (char-to-string CHAR))))

;; « C-x C-e » Tests:
;;
;; (sboo-unicode--prefix-namesake-character "SKULL")
;; (sboo-unicode--prefix-namesake-character "LATIN SMALL LETTER ALPHA")
;; (sboo-unicode--prefix-namesake-character "")
;;
;; (sboo-unicode--prefix-namesake-character "NULL")
;; (sboo-unicode--prefix-namesake-character "DIGIT ZERO")
;; (sboo-unicode--prefix-namesake-character "LATIN SMALL LETTER A")
;;

;;----------------------------------------------;;

(cl-defun sboo-unicode--annotate-character-p (char &key )

  "Whether `sboo-read-character' should annotate CHAR.

Inputs:

• CHAR — an `integerp'.
  A Unicode Character codepoint.

Output:

• a `booleanp'. 

Some characters can't be displayed (or shouldn't be annotated), including:

• Non-printable characters (e.g. NULL)
• Alphanumeric ASCII characters (e.g. LATIN SMALL LETTER A)

Examples:

    M-: (sboo-unicode--annotate-character-p ?💀)
      ⇒ t

    M-: (sboo-unicode--annotate-character-p ?-)
      ⇒ t

    M-: (sboo-unicode--annotate-character-p 0)
      ⇒ nil

    M-: (sboo-unicode--annotate-character-p ?0)
      ⇒ nil

    M-: (sboo-unicode--annotate-character-p ?a)
      ⇒ nil

    M-: (sboo-unicode--annotate-character-p ?Z)
      ⇒ nil

Links:

• URL `https://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html'"

  (let* ((UNPRINTABLE?        (< char 32))  ;TODO what about unprintables in higher-ranges? or surrogates?
         (ASCII-ALPHANUMERIC? (or (and (>= char ?0) (<= char ?9))
                                  (and (>= char ?A) (<= char ?Z))
                                  (and (>= char ?a) (<= char ?z))
                                  ))
         )

    (and (not UNPRINTABLE?)
         (not ASCII-ALPHANUMERIC?)
         )))

;;----------------------------------------------;;

(cl-defun sboo-unicode--insertable-character-p (char &key )

  "Whether `sboo-insert-char' can `insert' CHAR.

Inputs:

• CHAR — an `integerp'.
  A Unicode Character codepoint.

Output:

• a `booleanp'.

Some characters can't be inserted, including:

• Surrogates (e.g. TODO)

Links:

• URL `'"

  t)

;;----------------------------------------------;;

(defun sboo-unicode--strip-namesake-character (string)

  "Invert `sboo-unicode--prefix-namesake-character'.

Inputs:

• STRING — a `stringp'.

Output:

• a `stringp'. 

Examples:

    M-: (sboo-unicode--strip-namesake-character (sboo-unicode--prefix-namesake-character \"BULLET\"))
      ⇒ \"BULLET\"

Related:

• `sboo-unicode-completion-namesake-divider'"

  (let* ((LENGTH (sboo-unicode-completion-namesake-divider-length))
         )

    (if LENGTH
        (substring string (+ 1 LENGTH))
      string)))

;; (sboo-unicode--strip-namesake-character (sboo-unicode--prefix-namesake-character "BULLET"))

;;----------------------------------------------;;

(defun sboo-unicode--interesting-character-p (char)

  "Whether CHAR is an “interesting” Unicode Character.

Inputs:

• CHAR — an `integerp'.

Output:

• a `booleanp'."

  (let* ((UNPRINTABLE?        (< char 32))  ;TODO what about unprintables in higher-ranges? or surrogates?
         (ASCII-ALPHANUMERIC? (or (and (>= char ?0) (<= char ?9))
                                  (and (>= char ?A) (<= char ?Z))
                                  (and (>= char ?a) (<= char ?z))
                                  ))
         )

    (and (not UNPRINTABLE?)
         (not ASCII-ALPHANUMERIC?)
         )))

;;----------------------------------------------;;

(cl-defun sboo/alist->table (alist &key test size)

  "Create a Hash Table from ALIST.

Inputs:

• ALIST — an association `listp'. 
• TEST  — a `symbolp' (naming a `functionp'). See `make-hash-table'.
• SIZE  — an `integerp'. See `make-hash-table'.

Output:

• a `hash-table-p' with the same entries as ALIST (modulo duplicate keys).

Example:

• M-: (sboo/alist->table '((x . 1) (y . 2)) :test #'eq :size 3)
    ⇒ #s(hash-table size 3 test eq data (x 1 y 2))"

  (let* ((TEST  (or test
                    #'equal))

         (SIZE  (or size
                    (length alist)))

         (TABLE (make-hash-table :test TEST :size SIZE))

         )

    (progn

      (dolist (ENTRY alist)
        (let ((k (car ENTRY))
              (v (cdr ENTRY))
              )
          (puthash k v TABLE)))

      TABLE)))

;;----------------------------------------------;;
;; Notes ---------------------------------------;;
;;----------------------------------------------;;

;;; DOCS ‘ucs-names’: [TODO]
;;
;; « ucs-names » :: « HashMap String Char »
;;
;;     M-: (type-of ucs-names)
;;     'hash-table
;;
;; Examples:
;;
;;     M-: (gethash "BULLET" ucs-names)
;;     8226
;;     
;;     M-: '(?•)
;;     '(8226)
;;
;;     M-: (type-of (gethash "BULLET" ucs-names))
;;     'integer
;; 
;;     M-: (member "BULLET" (hash-table-keys ucs-names))
;;     t
;;

;;; DOCS ‘get-char-code-property’:
;;
;; « (get-char-code-property CHAR PROPNAME) »
;;
;; > M-: (get-char-code-property ?• 'name)
;; > "BULLET"
;; > 
;; > M-: (type-of (get-char-code-property ?• 'name))
;; > 'string
;; > 
;; > M-: (type-of char-code-property-table)
;; > 'char-table
;;
;; NOTE a char-table is sparse and compact, so `aref' doesn't quite work: [TODO why not?]
;;
;;     M-: (aref char-code-property-table ?•)
;;     nil
;;
;;     M-: (char-table-range char-code-property-table ?•)
;;     nil
;; 
;;     M-: 
;;     
;;
;;

;;; DOCS `map-char-table':
;;
;; « (map-char-table FUNCTION CHAR-TABLE) »
;;
;; > This function calls its argument function for each element of char-table that has a non-nil value. The call to function is with two arguments, a key and a value. The key is a possible range argument for char-table-range—either a valid character or a cons cell (from . to), specifying a range of characters that share the same value. The value is what (char-table-range char-table key) returns.
;;
;; NOTE:
;; > Standard mapping functions like `mapcar` do not allow char-tables because a char-table is a sparse array whose nominal range of indices is very large.
;;

;;; DOCS `mapcar':
;;
;; « (mapcar FUNCTION SEQUENCE) »
;;
;; > Apply FUNCTION to each element of SEQUENCE, and make a list of the results.
;; > The result is a list just as long as SEQUENCE.
;; > SEQUENCE may be a list, a vector, a bool-vector, or a string.
;;

;;; DOCS `insert-char':
;;
;; > DEFUN ("insert-char", Finsert_char, Sinsert_char, 1, 3,
;; >        "(list (read-char-by-name \"Insert character (Unicode name or hex): \")\
;; >               (prefix-numeric-value current-prefix-arg)\
;; >               t))",
;; >        doc: /* Insert COUNT copies of CHARACTER.
;; > Interactively, prompt for CHARACTER.  You can specify CHARACTER in one
;; > of these ways:
;; >
;; >  - As its Unicode character name, e.g. \"LATIN SMALL LETTER A\".
;; >    Completion is available; if you type a substring of the name
;; >    preceded by an asterisk `*', Emacs shows all names which include
;; >    that substring, not necessarily at the beginning of the name.
;; >
;; >  - As a hexadecimal code point, e.g. 263A.  Note that code points in
;; >    Emacs are equivalent to Unicode up to 10FFFF (which is the limit of
;; >    the Unicode code space).
;; > 
;; >  - As a code point with a radix specified with #, e.g. #o21430
;; >    (octal), #x2318 (hex), or #10r8984 (decimal).
;; >
;; > If called interactively, COUNT is given by the prefix argument.  If
;; > omitted or nil, it defaults to 1.
;; > 

;; NOTE `completion-extra-properties':
;;
;; * :annotation-function
;; * :exit-function
;;
;; 

;;; DOCS `cl-flet':
;;
;; e.g.
;;
;;    (require 'cl)
;;    (cl-flet ((f (x) (* x x)))
;;      (f 7))
;;

;;; DOCS `char-to-string':
;;
;; e.g.
;;
;;    M-: (char-to-string ?•)
;;    "•"

;;; See:
;;
;; ./share/emacs/26.1/lisp/international/uni-name.el 
;; 

;;==============================================;;
(provide 'sboo-unicode)

;;----------------------------------------------;;

data XdgDirectory

  = XdgData
    -- ^ For data files (e.g. images).
    --   Defaults to @~\/.local\/share@ and can be
    --   overridden by the @XDG_DATA_HOME@ environment variable.
    --   On Windows, it is @%APPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Roaming@).
    --   Can be considered as the user-specific equivalent of @\/usr\/share@.

  | XdgConfig
    -- ^ For configuration files.
    --   Defaults to @~\/.config@ and can be
    --   overridden by the @XDG_CONFIG_HOME@ environment variable.
    --   On Windows, it is @%APPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Roaming@).
    --   Can be considered as the user-specific equivalent of @\/etc@.

  | XdgCache
    -- ^ For non-essential files (e.g. cache).
    --   Defaults to @~\/.cache@ and can be
    --   overridden by the @XDG_CACHE_HOME@ environment variable.
    --   On Windows, it is @%LOCALAPPDATA%@
    --   (e.g. @C:\/Users\//\<user\>/\/AppData\/Local@).
    --   Can be considered as the user-specific equivalent of @\/var\/cache@.

;;----------------------------------------------;;

(pcase sboo-xdg-platform

  ('posix ())

  ('windows ())
  
  (_ ()))

;;----------------------------------------------;;


(cl-defun sboo-xdg-xyz (path &key subdir)

  "Make an xdg path for xyz files, from PATH.

Inputs:

• PATH   — a string. the suffix of the filepath to output.
• SUBDIR — a string. if non-nil (or absent), prefix PATH with SUBDIR.

Output: a string. \"$XDG_XYZ_HOME/SUBDIR/PATH\".

Example:

• M-: (sboo-xdg-xyz \"directory/basename.txt\")
      \"~/.directory/basename.txt\"

• M-: (sboo-xdg-xyz \"basename.txt\" :subdir \"directory\")
      \"~/.directory/basename.txt\"

« $XDG_XYZ_HOME » defaults to:

• « ~/.xyz » — on POSIX.
• «  » — on Windows.'

Use for (e.g. ).

See URL `https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html'.

Related:

• `sboo-xdg-xyz-default'
• `sboo-xdg-xyz-environment'"

  (let ((XdgPathEnvironment (getenv "XDG_XYZ_HOME"))
        (XdgPathDefault     "~/.xyz")
        (XdgPath            (if XdgPathEnvironment
                                XdgPathEnvironment
                              (file-name-as-directory XdgPathDefault)))
        (SubDirectory       (if subdir
                                (file-name-as-directory subdir)
                              ""))
        )

    (file-truename (cocnat XdgPath Subdir Path))))

;;----------------------------------------------;;


(defun sboo-next-buffer (count)
 
  "Move COUNT buffers 'forwards'.
"

  (interactive )

  (progn
  
    ()))

(defun sboo-prior-buffer (count)
 
  "Move COUNT buffers 'backwards'.
"

  (interactive )

  (progn
  
    ()))

;;----------------------------------------------;;

(defconst platform

  (cond                                 ;TODO pcase `(,system-type ,window-system)

   ((or (memq system-type   '(gnu/linux)))

    'platform-linux)

   ((or (memq system-type   '(cygwin windows-nt ms-dos))
        (memq window-system '(w32 pc)))

    'platform-windnows)

   ((or (memq system-type   '(darwin))
        (memq window-system '(mac ns)))

    'platform-apple)

   ((or (eq window-system 'x))  ;; TODO and Wayland?
    ;; ^ X11 runs on non-Linux operating-systems too (like Apple).

    'platform-linux)

   (t
    'platform-unknown))

  "The current platform, a symbol (prefixed with `platform-').

One of: 

* 'platform-linux
* 'platform-windows
* 'platform-apple
* 'platform-unknown

Depends on the variables `system-type' and `window-system'.")

;;----------------------------------------------;;

  (pcase `(,system-type . ,window-system)

    ( `( ,(or 'gnu/linux) . ,_ )

      'platform-linux)

    ( `( ,_ . ,_ )

      'platform-unknown))

;;----------------------------------------------;;

  (pcase (list system-type window-system)

    ( `(,(or 'gnu/linux) ,_)

      'platform-linux)

    ( ,_

      'platform-unknown))

  
;;----------------------------------------------;;
  (use-package dante
    :after    haskell

    :commands (dante-mode dante-restart)

    :bind (:map haskell-mode-map
                (("C-c d" . sboo-dante-mode)))

;;;  :hook ((haskell-mode . flycheck-mode)
;;;         (haskell-mode . dante-mode))

    :init
    (add-hook 'haskell-mode-hook #'flycheck-mode)
    (add-hook 'haskell-mode-hook #'dante-mode)

    :config
    (setq dante-repl-command-line-methods-alist
          sboo-dante-repl-command-line-methods-alist)

    (setq sboo-haskell-eldoc 'dante)

    (setq dante-tap-type-time 2)

    ())

;;----------------------------------------------;;

(defun sboo--ghc-pragma-read (prompt candidates)

  "Read a candidate from CANDIDATES.

Output:

• a string.

Related:

• `sboo-ghc-pragma-read-pragma'.
• `sboo-ghc-pragmas-alist'."

  (interactive)

  (completing-read (format "%s: " prompt)
                   candidates))

;;----------------------------------------------;;

(defun sboo-ghc-pragma-read-pragma ()

  "Read a GHC pragma.

Related:

• `sboo-ghc-pragmas-alist'."

  (interactive)

  (let ((prompt     "Pragma")
        (candidates sboo-ghc-pragmas)
        )

    (completing-read (format "%s: " prompt)
                     candidates)))

;;----------------------------------------------;;

(defun sboo-ghc-pragma-insert-pragma (&optional pragma)

  "Insert a GHC pragma, reading it if PRAGMA is nil.

Related:

• `sboo-ghc-pragma-read-pragma'."

  (interactive (list
                (sboo-ghc-pragma-read-pragma)))

  (let* ((STRING (format "{-# %s #-}" pragma))
         )

    (insert STRING "\n")))

;;----------------------------------------------;;

(defalias 'sboo-ghc-read-WARNING    #'sboo-ghc-read-string)
(defalias 'sboo-ghc-read-DEPRECATED #'sboo-ghc-read-string)

;;----------------------------------------------;;
sboo-ghc-get-names-of-definitions-current-file
;;----------------------------------------------;;
(defmacro sboo-move-to-head-of-alist! (key alist)

  "Move KEY and its value to the `car' of ALIST.

Inputs:

• KEY — is one of: `symbolp', `stringp', or `numberp'.

• ALIST — is an `alist' variable. 
          its key-type is equal to the `type-of' KEY.

Output:

• an `alist'.

• ALIST is mutated too."

  `(setq ,variable (append ,list ,variable)))

;;----------------------------------------------;;

(cl-defun sboo-submodule-directory (package-name &key version)
  "Return « \"`sboo-submodule-directory'/`PACKAGE-NAME-VERSION'\" ».

Examples:

• M-: (add-to-list 'load-path (sboo-submodule-directory \"use-package\")
    ⇒ \"/home/sboo/.emacs.d/submodules/use-package/\"

• M-: (add-to-list 'load-path (sboo-submodule-directory \"use-package\" :version \"2.3\")
    ⇒ \"/home/sboo/.emacs.d/submodules/use-package-2.3/\"

Links:

• URL `https://git-scm.com/book/en/v2/Git-Tools-Submodules'.
• URL `https://chrisjean.com/git-submodules-adding-using-removing-and-updating/'."

  (let* ((PackageDirectoryPrefix (concat sboo-vendored-package-directory package-name))

	 (VersionSuffix          (if version
	                             (format "-%s" version)
                                   ""))

	 (PackageDirectory (file-name-as-directory
                            (concat PackageDirectoryPrefix VersionSuffix)))
         )

    PackageDirectory))

;;----------------------------------------------;;

TODO

  (use-package dante
     :load-path (sboo-submodule-directory "dante")

;; Error (use-package): Failed to parse package dante: Symbol’s value as variable is void: sboo-submodule-directory


;;----------------------------------------------;;

(cl-defun sboo-deep-copy-alist (alist)

  "Copy ALIST deeply (i.e. recursively).

Inputs:

• ALIST — is an `alist'.

Output:

• an `alist' with the same keys and values as ALIST."

  (mapcar #'copy-sequence alist))

;;----------------------------------------------;;

(use-package lisp-mode

  :init

  ()

  :bind (:map lisp-mode-map
              ("[" . sboo-insert-open-parenthesis)
              ("]" . sboo-insert-close-parenthesis)
              ("(" . sboo-insert-open-square-bracket)
              (")" . sboo-insert-close-square-bracket)
              )

  :config 

  ())

;;----------------------------------------------;;

(use-package lisp-mode

  :init

  ()

  :bind (:map lisp-mode-map
              ("[" . sboo-insert-open-parenthesis)
              ("]" . sboo-insert-close-parenthesis)
              ("(" . sboo-insert-open-square-bracket)
              (")" . sboo-insert-close-square-bracket)
              )

  :config 

  ())

;;----------------------------------------------;;


    (when sboo-dante-method-default
      (setq dante-methods-alist
            (sboo-move-to-head-of-alist dante-methods-alist :key sboo-dante-method-default)))

;;----------------------------------------------;;

  (defun sboo-edit-indirect-guess-mode (parent-buffer parent-region-begin parent-region-end)

    "Guess the major mode for an edit-indirect buffer.

Calls `set-auto-mode', which parses the « mode » file-local (special) variable 
(i.e. « -*- mode: ... -*- »)."

    (set-auto-mode t)

    (if-let* (
              )

        ()

      (prog-mode)))

;;----------------------------------------------;;


(defun sboo-read-character-name-via-collection ()

  "Read a Unicode character name, returning the string `NAME'.

Haskell Type « :: IO String ».

See `ucs-names'."

  (completing-read "Unicode character name: " sboo-unicode-names-list nil t))

;;----------------------------------------------;;

(defun sboo-annotate-character-name-with-character-literal (name)

  "Annotate `NAME' (e.g. \"BULLET\") with the char itself (e.g. ?•).

Haskell Type « :: String -> String ».
"
  ;TODO(throw 'sboo NAME)

  (let ((CHAR
         (gethash name sboo-unicode-names-hash-table)))

    (if CHAR
        (let ((PRINTABLE
               t)) ;;TODO check 'general-category for whether character is printable (or is control)

          (if PRINTABLE
              (let ((ANNOTATED
                     (format-message "%s  %s" (char-to-string CHAR) name)))
              ;; (let ((ANNOTATION
              ;;        (format-message " %s" (char-to-string CHAR))))

                ANNOTATED)
            name)))))

;;----------------------------------------------;;

(defun sboo-read-character-name-with-annotations ()

  "Read a Unicode character name, returning the string `NAME'.

Annotates each completion candidate with the unicode character being named.

Haskell Type « :: IO String ».

Calls `completing-read' with Info node ‘(elisp)Programmed Completion’"

  (let ((completion-extra-properties
         '(:annotation-function sboo-annotate-character-name-with-character-literal)))

    (completing-read "Unicode character name: " sboo-unicode-names-hash-table nil t)))

;; ^
;;     M-: (message (sboo-read-character-name-with-annotations))

;;----------------------------------------------;;

(defun sboo-read-character-with-literals-displayed ()

  "Read a Unicode character name, returning the string `NAME'.

Prepends each completion candidate with the unicode character being named
(which must then be stripped back out).

Haskell Type « :: IO String ».

Calls `completing-read' with ‘(elisp)Programmed Completion’"

  (let* ((COMPLETION
          (completing-read "Unicode character (char & name): " sboo-unicode-completion-descriptions-hash-table nil t))
         (CHAR
          (gethash COMPLETION sboo-unicode-completion-descriptions-hash-table)))

    CHAR))

;; ^
;;     M-: (message (sboo-read-character-with-literals-displayed))

;;----------------------------------------------;;

(cl-defun sboo-read-character (&key method display)

  "Read a Unicode character name, returning the string `NAME'.

Inputs:

• NAME    — a `stringp'. The name of the unicode character.
• DISPLAY — a `booleanp'. Whether to display the unicode character itself (beside the name).

Wraps `sboo-read-character-with-literals-displayed', `sboo-read-character-name-with-annotations', `sboo-read-character-name-via-collection'."

  (let ((CHAR-READER
         (if METHOD METHOD #'sboo-read-character-with-literals-displayed))) ;TODO shorter aliases (than full names) in keywords).

    (call-interactively CHAR-READER)))

;;TODO function (not command) alias?
;; (defalias sboo-read-character-name #'sboo-read-character-name-with-annotations)













;;----------------------------------------------;;

(defun sboo-get-unicode-names-list ()

  "Construct `sboo-unicode-names-list'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  (hash-table-keys ucs-names))

  ;; (let ((NAMES '()))

  ;;   (progn
  ;;     (cl-flet ((ADD-CHAR-NAME (CHAR PROPERTIES)
  ;;                              (add-to-list 'NAMES (aget PROPERTIES 'name)))) ;TODO

  ;;       (map-char-table #'ADD-CHAR-NAME
  ;;                       char-code-property-table))

  ;;     NAMES)))

;;----------------------------------------------;;

(defun sboo-get-unicode-names-hash-table ()

  "Construct `sboo-unicode-names-hash-table'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  ucs-names)

;;----------------------------------------------;;

(defun sboo-get-unicode-completion-description-hash-table ()

  "Construct `sboo-unicode-completion-descriptions-hash-table'.

Via `ucs-names'."

  (unless ucs-names
    (ucs-names))
  ;; ^ Initialize if uninitialized.

  ucs-names

  )








;;;###autoload
(defvar sboo-unicode-names-list (sboo-get-unicode-names-list)

  "The list of each Unicode character's (unique) `name'.

Haskell Type « :: [String] ».

[TODO ordered list?]

[TODO « Map Char String »]

e.g...

    M-: (consp (member \"BULLET\" sboo-unicode-names-list))
    t

")

;;----------------------------------------------;;

;;;###autoload
(defvar sboo-unicode-names-hash-table (sboo-get-unicode-names-hash-table)

  "The mapping from each Unicode character `name' to its character.

Equals `ucs-names'.

Haskell Type « :: Map Char String ».

Examples:

    M-: (gethash \"BULLET\" sboo-unicode-names-hash-table)
    ?•
")

;; M-: (gethash "BULLET" ucs-names)

;;----------------------------------------------;;

;;;###autoload
(defvar sboo-unicode-completion-descriptions-hash-table (sboo-get-unicode-completion-description-hash-table)

  "The mapping from each Unicode character `name' to a description thereof.

This description combines the name of the character with said character being named.
In particular, each table-key is a Unicode Character Codepoint (the table-value) 
prepended to its Unicode Character Name (with a space).
For example, one entry is:

    (:key   \"• BULLET\"
     :value ?•
    )

Provides caching for completion.

NOTE Why does this exist when `sboo-unicode-names-hash-table' does too? 
Because currently (circa 2018), `helm' doesn't support the `:annotation-function' property of `completion-extra-properties'.

Derived from `ucs-names'.

Haskell Type « :: Map String Char ».

Examples:

    M-: (gethash \"• BULLET\" sboo-unicode-completion-descriptions-hash-table)
    ?•

    M-: (gethash \"BULLET\" sboo-unicode-completion-descriptions-hash-table)
    nil

    M-: (gethash \"•\" sboo-unicode-completion-descriptions-hash-table)
    nil")

;; ^
;;     M-: (gethash "• BULLET" sboo-unicode-completion-descriptions-hash-table)
;;     ?•







(cl-defun sboo/alist->table (alist &key test size)

  "Create a Hash Table from ALIST.

Inputs:

• ALIST — an association `listp'. 
• TEST  — a `symbolp' (naming a `functionp'). See `make-hash-table'.
• SIZE  — an `integerp'. See `make-hash-table'.

Output:

• a `hash-table-p' with the same entries as ALIST (modulo duplicate keys).

Example:

• M-: (sboo/alist->table '((x . 1) (y . 2)) :test #'eq :size 3)
    ⇒ #s(hash-table size 3 test eq data (x 1 y 2))
"

  (let* ((TEST  (or test
                    #'equal))

         (SIZE  (or size
                    (length alist)))

         (TABLE (make-hash-table :test TEST :size SIZE))

         )

    (progn

      (mapc #'add-entry alist)

      TABLE)))



(defun sboo-ucs-names-get (name)

  "Get the Unicode Character whose name is NAME.

Inputs:

• NAME — a `stringp'.
  The name of a Unicode Character.

Output:

• an `integerp'.
  a Unicode Character codepoint.

Type (Haskell):

• « :: String -> Maybe Char »

Example:

• M-: (format \"%c\" (sboo-ucs-names-get \"BULLET\"))
    ⇒ \"•\"
• M-: (sboo-ucs-names-get \"NOT A UNINCODE CHARACTER NAME\")
    ⇒ nil
"

  (let* ((NAME   (upcase name))
         (OBJECT (sboo-ucs-names-table))
         (TYPE   (type-of OBJECT))
         (CHAR   (pcase TYPE
                   ('hash-table (gethash NAME OBJECT))
                   ('list       (alist-get NAME OBJECT nil nil #'equal))
                   (_           nil)))
         )

    CHAR))

;; ^ (format "%c" (sboo-ucs-names-get "BULLET"))

;;----------------------------------------------;;

(require 'regexp-opt)
(require 'faces)
(require 'color)

;;----------------------------------------------;;

(cl-defun sboo-things (&key fast)

  "List all known things for `forward-thing'.

Inputs:

• FAST — a `booleanp'.

Output:

• a `listp' of `symbolp's.

Example:

• M-: (sboo-things :fast t)

Related:

• `sboo-things-builtin'
• `sboo-things-custom'
• `forward-thing'"

  (let* ((KNOWN-THINGS (append sboo-things-builtin sboo-things-custom))
         )

    (if fast
        KNOWN-THINGS

      (let* ((THINGS-VIA-SYMBOL-PROPERTY (mapatoms sboo-thing-by-property &optional obarray))
             (THINGS-VIA-FUNCTION-NAMES  (mapatoms sboo-thing-by-name     &optional obarray))

             (UNKNOWN-THINGS (append THINGS-VIA-FUNCTION-NAMES THINGS-VIA-SYMBOL-PROPERTY))
             )

        (append KNOWN-THINGS UNKNOWN-THINGS)))))

;;----------------------------------------------;;

• M-: (sboo-forward-ops)

    ⇒ (list #'forward-str #'forward-page #'forward-op #'forward-line #'forward-list #'forward-word #'forward-point #'forward-button #'forward-symbol #'forward-sentence #'forward-paragraph #'end-of-defun #'forward-char #'forward-comment #'forward-whitespace #'forward-thing #'forward-sexp)

    ⇒ (list #'forward-page #'forward-line #'forward-list #'forward-word #'forward-point #'forward-button #'forward-symbol #'forward-sentence #'forward-paragraph #'end-of-defun #'forward-char #'forward-comment ...))

;;----------------------------------------------;;

(cl-defun sboo-color-parse-json (&key file string)

  "Parse a json STRING or FILE, whose schema is a list of `sboo-color-name'.

Inputs:

• FILE — a « .json » file.
• STRING — a json string.

Output:

• a list of `sboo-color-name's.

Example:

• M-: (sboo-color-parse-json :string \"[{\\\"name\\\":\\\"1975 Earth Red\\\",\\\"hex\\\":\\\"#7a463a\\\"}]\")
    ⇒ [ ... ]

• M-: (sboo-color-parse-json :file \"colornames.json\")
    ⇒ [ ... ]

Links:

• URL `https://unpkg.com/color-name-list@3.64.0/dist/colornames.json"

  (let* ((JSON (if (stringp string)
                   string
                 (if (stringp file)
                     (read file)
                   (throw 'sboo-color-parse-json))))
         )

    (let* ((json-object-type 'hash-table)
           (json-array-type  'list)
           (json-key-type    'string)
           (TABLE            (json-read-file file)))

      TABLE)))

;; ^ e.g.:
;;
;; (sboo-color-parse-json :string "[{\"name\":\"1975 Earth Red\",\"hex\":\"#7a463a\"}]")
;; (sboo-color-parse-json :file   "colornames.json")
;;

;;----------------------------------------------;;

  (let* ((PLIST (plist-get property-list))
         )

    (make-mtg-card @PLIST)))

;;----------------------------------------------;;

  (let* ((SUBLIST   (copy-sequence sublist))
         (SUPERLIST (copy-sequence superlist))
         )

    (dolist (ITEM SUPERLIST)
      (when (member ITEM sublist)
        (push ITEM SUBLIST)))

    (append SUBLIST SUPERLIST)))

  (let* ((SUBLIST-COPY (copy-sequence sublist))
         (SUBLIST      nil)
         (SUPERLIST    nil)
         )

    (dolist (SUPER-ITEM superlist)
      (when (member ITEM sublist)
        (push ITEM SUBLIST)))

    (append SUBLIST SUPERLIST)))

         (COMPARE      (lambda (x y)
                         (let ((X-IN-SUBLIST (if (member x sublist) t nil))
                               (Y-IN-SUBLIST (if (member y sublist) t nil))
                               )
                           ())))

;;----------------------------------------------;;
# -*- mode: snippet -*-
#
# key         : sboo-insert
# name        : a « defun » wrapping sboo-insert-char.
# type        : snippet
# expand-env  : ((yas-indent-line 'auto) (yas-wrap-around-region 'nil))
# condition   : (let ((KEY "sboo-insert")) (condition-case nil (= (current-column) (string-width KEY)) (error t)))
#
# --
;;----------------------------------------------;;

(defun sboo-insert-${1:$(string-join (split-string (downcase yas-text)) "-")} ()
  "`insert' ?${1:$(ignore-errors (format "%c" (gethash yas-text (ucs-names))))}, the \\"${1:$$(progn (require 'mule) (require 'subr-x) (let ((CHAR-NAME (yas-choose-value (hash-table-keys (ucs-names))))) CHAR-NAME))}\\" Unicode character."
  (interactive)
  (insert-char ?${1:$(ignore-errors (format "%c" (gethash yas-text (ucs-names))))}))

$0

;;----------------------------------------------;;
(defun sboo-insert-{1:$$(progn (require 'mule) (require 'subr-x) (let ((CHAR-NAME (yas-choose-value (hash-table-keys (ucs-names))))) (string-join (split-string (downcase CHAR-NAME)) "-")))}
  "`insert' ?${1:$(format "%c" (gethash yas-text (ucs-names)))}, the \\"${1:$(string-join (split-string (upcase yas-text) "[-]+" :omit-nulls) " ")}\\" Unicode character."
  (interactive)
  (insert-char ?${1:$(format "%c" (gethash yas-text (ucs-names)))}))

$0
;;----------------------------------------------;;
(defun sboo-insert-${1:$$(progn (require 'mule) (require 'subr-x) (let ((CHAR-NAME (yas-choose-value (hash-table-keys (ucs-names))))) (string-join (split-string (downcase CHAR-NAME)) "-")))}
  "`insert' ?${1:$(format "%c" (gethash yas-text (ucs-names) ?α))}, the \\"${1:$(string-join (split-string (upcase yas-text) "[-]+" :omit-nulls) " ")}\\" Unicode character."
  (interactive)
  (insert-char ?${1:$(format "%c" (gethash yas-text (ucs-names) ?α))}))

$0
;;----------------------------------------------;;
(defcustom sboo-nix-build-file-regexp

  (rx " "
      "at" (group-n 1 (one-or-more (any "./~" "a-f" "A-F" "0-9")) ".nix")
      ":"  (group-n 2 (one-or-more digit))
      ":"  (group-n 3 (one-or-more digit))
      )

;;----------------------------------------------;;
(let* ((G-FILENAME 1)
       (G-LINE     2)
       (G-COLUMN   3)
       (REGEXP     (rx (group-n G-FILENAME (1+ (or "/~." letter digit)) ".nix")
                       (? ":" (group-n G-LINE (1+ digit))
                          (? ":" (group-n G-COLUMN (1+ digit)))))))

  (let ((STRING "~/default.nix:999:78"))

    (string-match REGEXP STRING)

    (list (match-string G-FILENAME STRING)
          (match-string G-LINE     STRING)
          (match-string G-COLUMN   STRING))))
;;----------------------------------------------;;


(defun sboo-init-use-package ()

  "Register and initialize `use-package'.

Links:

• URL `https://github.com/jwiegley/use-package'"

  (let* ()

    (progn

      (sboo-register-submodule-packages! "use-package")

      (progn
     ;; (eval-when-compile (require 'use-package))

        (eval-when-compile (add-to-list 'load-path (expand-file-name "~/.emacs.d/submodules/use-package/")))
        (eval-when-compile (require 'use-package (expand-file-name "~/.emacs.d/submodules/use-package/use-package.el")))

        (require 'diminish)
        (require 'bind-key)

        (setq use-package-verbose t)))))

;;----------------------------------------------;;

(defun yaml-mode-version ()
  "Display version of `yaml-mode'."
  (interactive)
  (message "yaml-mode %s" yaml-mode-version)
  yaml-mode-version)

;;;###autoload
(add-to-list 'auto-mode-alist '("\\.\\(e?ya?\\|ra\\)ml\\'" . yaml-mode))

;;----------------------------------------------;;

    
    (split-string text *separators* *omit-nulls* *separators*)))

;;----------------------------------------------;;

  (declare (side-effect-free t))

  (let ((*separators* "[ -/]+")
        (*omit-nulls* t)
        )

    (let* ((WORDS (split-string text split-string-default-separators t split-string-default-separators))
           )

      WORDS)))

;;----------------------------------------------;;
(cl-defun sboo-case-tokenize (text &key (steganograph nil))

  "Split TEXT into tokens.

Inputs:

• TEXT         — a `stringp'.
• STEGANOGRAPH — a `booleanp'. 
  (invisibly) `propertize' the output with the TEXT;
  this upgrades `sboo-case-tokenize' into a lossless transformation) helps other casing functions
  (e.g. `sboo-case-invert') preserve the original tokens (e.g. acronyms),
  including lossy transformations

Output:

• a `listp' of `stringp's.

Example:

• M-: (sboo-case-tokenize \"\")
    ⇒ '()

• M-: (sboo-case-tokenize \" two  words \" :steganograph nil)
    ⇒ '(\"two\" \"words\")

• M-: (sboo-case-tokenize \"two-words and/or sub_words\")
   ⇒ '(\"two\" \"-\" \"words\" \"and\" \"/\" \"or\" \"sub\" \"_\" \"words\")

Notes:

• By default, the tokens are words.

Related:

• `sboo-case-preserve-acronyms' (customizeable)"

  (declare (side-effect-free t))

  (let ((*separator-regex* "[_-/ \f\t\n\r\v]+")
        (*omit-nulls*      t)
        (*trim-regex*      "[ \f\t\n\r\v]+")
        )

    (let* ((WORDS (split-string text *separator-regex* *omit-nulls* *trim-regex*))
           )

      WORDS)))

;; M-: (sboo-case-tokenize " two  words " :steganograph nil)
;;  ⇒ '("two" "words")

;; M-: (sboo-case-tokenize "two-words and/or sub_words")
;;  ⇒ '("two" "-" "words" "and" "/" "or" "sub" "_" "words")

;; M-: (split-string "two-words and/or sub_words")
;;  ⇒ '("two-words" "and/or" "sub_words")

;;----------------------------------------------;;

(defun s-split (separator s &optional omit-nulls)
  "Split S into substrings bounded by matches for regexp SEPARATOR.
If OMIT-NULLS is non-nil, zero-length substrings are omitted.

This is a simple wrapper around the built-in `split-string'."
  (declare (side-effect-free t))
  (save-match-data
    (split-string s separator omit-nulls)))

(defun s-split-words (s)
  "Split S into list of words."
  (declare (side-effect-free t))
  (s-split
   "[^[:word:]0-9]+"
   (let ((case-fold-search nil))
     (replace-regexp-in-string
      "\\([[:lower:]]\\)\\([[:upper:]]\\)" "\\1 \\2"
      (replace-regexp-in-string "\\([[:upper:]]\\)\\([[:upper:]][0-9[:lower:]]\\)" "\\1 \\2" s)))
   t))

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

;;----------------------------------------------;;

